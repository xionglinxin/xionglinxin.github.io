<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Wblog
    </title>
    <meta name="description" content= 终身学习，记录成长轨迹 >
    <meta name="keywords" content= Blog,Hexo,技术,学习,linxin >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            CVE-2025-55182 (React2Shell)
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="CVE-2025-55182-React2Shell"><a href="#CVE-2025-55182-React2Shell" class="headerlink" title="CVE-2025-55182 (React2Shell)"></a><strong>CVE-2025-55182 (React2Shell)</strong></h1><h3 id="漏洞执行流程图"><a href="#漏洞执行流程图" class="headerlink" title="漏洞执行流程图"></a>漏洞执行流程图</h3><pre class="mermaid">flowchart TD
    A[攻击者发送 Payload] --> B[解析入口 decodeReplyFromBusboy]
    B --> C{解析 Multipart 字段}

    subgraph "阶段一 注册恶意回调 与 原型链遍历"
        C -->|遇到 Chunk 0| D[解析 Chunk 0 JSON]
        D --> E[处理 Key]
        E --> F[解析引用 Chunk 1]
        F -->|Chunk 1 状态为 PENDING| G[注册 resolve 回调]
        G --> H[等待触发 用 Chunk 1 属性填充 Chunk 0]
    end

    subgraph "阶段二 触发回调 与 构造伪造 Chunk"
        C -->|遇到 Chunk 1| I[解析 Chunk 1]
        I --> J[解析 Promise 引用]
        J -->|Chunk 0 已存在| K[触发 Chunk 1 状态变为 INITIALIZED]
        K --> L[执行阶段一回调 wakeChunk]
        L --> M[执行 reviveModel 进行对象还原]
        M --> N{遍历路径 1 __proto__ then}
        N -->|无 hasOwnProperty 检查| O[获取 Chunk.prototype.then]
        O --> P[将 Chunk 0.then 赋值为 Chunk.prototype.then]
        P --> Q[将 _formData.get 指向 Function 构造函数]
    end

    subgraph "阶段三 Thenable 自动解包 与 代码执行"
        Q --> R[Chunk 0 变为 Thenable 对象]
        R --> S[系统 await 或 resolve Chunk 0]
        S -->|自动调用 then| T[执行 Chunk.prototype.then]
        T --> U[内部调用 initializeModelChunk 再调用 reviveModel]
        U --> V[解析 value B1337]
        V --> W[进入 Blob 处理分支 Case B]
        W --> X[调用 response._formData.get]
        X -->|get 已被替换为 Function| Y[执行 Function 恶意代码]
        Y --> Z((RCE 远程代码执行))
    end</pre>

<blockquote>
<p>关键值：<code>$1:__proto__:then</code>、<code>$@0</code>、<code>$B1337</code></p>
</blockquote>
<hr>
<h3 id="详细步骤解析"><a href="#详细步骤解析" class="headerlink" title="详细步骤解析"></a>详细步骤解析</h3><h4 id="1-初始输入-Attack-Vector"><a href="#1-初始输入-Attack-Vector" class="headerlink" title="1. 初始输入 (Attack Vector)"></a>1. 初始输入 (Attack Vector)</h4><p>攻击者发送一个 <code>multipart/form-data</code> 请求，包含两个部分：</p>
<ul>
<li><strong>Chunk 0 (Payload)</strong>: 一个精心构造的 JSON 对象，包含 <code>$1:__proto__:then</code> 这样的恶意 Key，以及恶意的 <code>value</code> 和 <code>_response</code> 属性。</li>
<li><strong>Chunk 1 (Trigger)</strong>: 内容为 <code>&quot;$@0&quot;</code>，用于引用 Chunk 0 并触发 Promise 机制。</li>
</ul>
<h4 id="2-阶段一：埋下伏笔-注册回调"><a href="#2-阶段一：埋下伏笔-注册回调" class="headerlink" title="2. 阶段一：埋下伏笔 (注册回调)"></a>2. 阶段一：埋下伏笔 (注册回调)</h4><ul>
<li><strong>解析入口</strong>: 服务端通过 <code>decodeReplyFromBusboy</code> 开始流式解析数据。</li>
<li><strong>遇到引用</strong>: 在解析 Chunk 0 时，遇到 Key <code>&quot;$1:__proto__:then&quot;</code>。React 尝试解析 <code>$1</code> (即 Chunk 1)。</li>
<li><strong>状态挂起</strong>: 此时 Chunk 1 尚未解析完成（状态为 <code>PENDING</code>），React 会调用 <code>chunk.then</code> 注册一个回调函数（<code>createModelResolver</code>），等待 Chunk 1 就绪后执行。<strong>这个回调函数的目的是：当 Chunk 1 就绪后，沿着 <code>__proto__:then</code> 路径去取值，并赋给 Chunk 0</strong>。</li>
</ul>
<h4 id="3-阶段二：触发与污染-构造-Fake-Chunk"><a href="#3-阶段二：触发与污染-构造-Fake-Chunk" class="headerlink" title="3. 阶段二：触发与污染 (构造 Fake Chunk)"></a>3. 阶段二：触发与污染 (构造 Fake Chunk)</h4><ul>
<li><p><strong>解析触发器</strong>: 解析到 Chunk 1 (<code>$@0</code>)。<code>$@</code> 表示这是一个 Promise 引用。</p>
</li>
<li><p><strong>唤醒回调</strong>: Chunk 1 解析完成，状态变为 <code>INITIALIZED</code>，触发之前注册的回调函数 (<code>wakeChunk</code>)。</p>
</li>
<li><p>路径遍历 (漏洞点)</p>
<p>: 回调函数执行 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reviveModel</span><br></pre></td></tr></table></figure>

<p> 逻辑，沿着 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;1&quot;, &quot;__proto__&quot;, &quot;then&quot;]</span><br></pre></td></tr></table></figure>

<p> 路径查找属性。</p>
<ul>
<li><strong>关键缺陷</strong>: 代码中使用了 <code>for (key in value)</code> 且<strong>没有使用 <code>hasOwnProperty</code> 检查</strong>。</li>
<li><strong>结果</strong>: 系统错误地读取到了 JavaScript 原型链上的 <code>Chunk.prototype.then</code>。</li>
</ul>
</li>
<li><p>完成伪造</p>
<p>: 同样的逻辑被用于将 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_formData.get</span><br></pre></td></tr></table></figure>

<p> 属性指向 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function</span><br></pre></td></tr></table></figure>

<p> 构造函数 (通过 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructor.constructor</span><br></pre></td></tr></table></figure>

<p>)。</p>
<ul>
<li>此时，Chunk 0 变成了一个**伪造的 Chunk (Fake Chunk)**，它拥有合法的 <code>then</code> 方法和恶意的 <code>_formData</code>。</li>
</ul>
</li>
</ul>
<h4 id="4-阶段三：执行陷阱-RCE"><a href="#4-阶段三：执行陷阱-RCE" class="headerlink" title="4. 阶段三：执行陷阱 (RCE)"></a>4. 阶段三：执行陷阱 (RCE)</h4><ul>
<li><p><strong>自动解包</strong>: 由于 Chunk 0 现在拥有 <code>then</code> 方法，它被视为一个 <strong>Thenable</strong> 对象。在 JS 的 <code>await</code> 或 <code>Promise</code> 处理中，会自动执行这个 <code>then</code> 方法。</p>
</li>
<li><p><strong>进入 React 逻辑</strong>: 伪造的 <code>then</code> 指向了合法的 <code>Chunk.prototype.then</code>，这会让 React 误以为这是一个正常的内部对象，并开始解析其 <code>value</code> 部分 (<code>&#123;&quot;then&quot;:&quot;$B1337&quot;&#125;</code>)。</p>
</li>
<li><p>Blob 解析漏洞</p>
<p>: 解析器遇到 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$B</span><br></pre></td></tr></table></figure>

<p> (Blob 类型) 开头的数据。</p>
<ul>
<li>正常逻辑：调用 <code>response._formData.get(blobKey)</code> 获取文件数据。</li>
<li><strong>被劫持逻辑</strong>: 由于 <code>get</code> 已经被替换为 <code>Function</code>，且 <code>blobKey</code> 部分可控 (包含恶意代码字符串)，代码变成了执行 <code>Function(&quot;恶意代码...&quot;)</code>。</li>
</ul>
</li>
<li><p><strong>代码执行</strong>: 恶意代码被执行，完成 RCE。</p>
</li>
</ul>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 linxin | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>


    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.4.0/dist/mermaid.min.js"></script>
    <script>
        if (window.mermaid) {
            mermaid.initialize({"theme":"default","startOnLoad":true});
        }
    </script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>

    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
